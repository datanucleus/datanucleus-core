################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contributors:
# 2007 Xuan Baldauf - Make error message "023011" a little bit more verbose
#    ...
#
# Resources for org.datanucleus package
################################################################################
#
# ClassLoader
#
001000=Class "{0}" was not found in the CLASSPATH. Please check your specification and your CLASSPATH.
001001=Persistence process has been specified to use a ClassLoaderResolver of name "{0}" yet this has not been found by the DataNucleus plugin mechanism. Please check your CLASSPATH and plugin specification.
001002=ClassLoaderResolver specified to use class "{0}" yet this class is not found! Please check your CLASSPATH and plugin specification.
001003=ClassLoaderResolver for class "{0}" gave error on creation : {1}
001004=Class "{0}" was not found in the CLASSPATH [Class resolver called from {1} (line={2})]
001005=Class "{0}" was not found in the CLASSPATH when trying to resolve classes
001006=Class "{0}" was not present in the CLASSPATH. You need to have "{1}" in the CLASSPATH!

#
# DatastoreIdentity
#
002001=Persistence process has been specified to use datastore-identity of name "{0}" yet this has not been found by the DataNucleus plugin mechanism. Please check your CLASSPATH and plugin specification.
002002=datastore-identity "{0}" specified to use class "{1}" yet this class is not found! Please check your CLASSPATH and plugin specification.
#
# L1 Cache
#
003001=Level 1 Cache "{0}" is not registered. Please check your CLASSPATH and specification.
003002=Level 1 Cache "{0}" is registered to use class "{1}" yet this is not found. Please check your CLASSPATH and plugin specification.
003003=Level 1 Cache of type "{0}" initialised
003004=Object "{0}" (id="{1}") added to Level 1 cache (loadedFlags="{2}")
003005=Object "{0}" (id="{1}") updated in Level 1 cache (loadedFlags="{2}")
003006=Attempt to add null object to Level 1 cache. Rejected.
003007=Object with id "{0}" not found in Level 1 cache [cache size = {1}]
003008=Object "{0}" (id="{1}") taken from Level 1 cache (loadedFlags="{2}") [cache size = {3}]
003009=Object with id="{0}" being removed from Level 1 cache [current cache size = {1}]
003010=Object with id="{0}" couldnt be removed from Level 1 cache - wasnt present.
003011=Level 1 Cache cleared
003012=Object "{0}" (id="{1}") being changed to be referenced by id="{2}" in Level 1 cache
#
# L2 Cache
#
004000=Level 2 Cache "{0}" is not registered. Please check your CLASSPATH and specification.
004001=Level 2 Cache "{0}" is registered to use class "{1}" yet this is not found. Please check your CLASSPATH and plugin specification.
004002=Level 2 Cache of type "{0}" initialised
004003=Object "{0}" (id="{1}") added to Level 2 cache (fields="{2}", version="{3}")
004004=Attempt to add null object to Level 2 cache. Rejected.
004005=Object with id "{0}" not found in Level 2 cache
004006=Object with id="{0}" taken from Level 2 cache (fields="{1}", version="{2}") - represented as "{3}"
004007=Object "{0}" (id="{1}") removed from Level 2 cache
004008=Object "{0}" (id="{1}") couldnt be removed from Level 2 cache - wasnt present.
004009=Level 2 Cache cleared
004010=Object "{0}" (id="{1}") being changed to be referenced by id="{2}" in Level 2 cache
004011=Attempt to put a null object into the cache.
004012=Unable to add object with id "{0}" to L2 Cache since it is still attached to a PersistenceManager.
004014=Object with id="{0}" removed from Level 2 cache since was updated yet object has been GCed
004015=Object "{0}" (id="{1}") updated in Level 2 cache (fields="{2}", version="{3}") - fields updated="{4}"
004016=Object with id="{0}" removed from Level 2 cache

#
# FetchPlan
#
006000=Field "{0}" declared in the fetch-group "{1}" was not found in the class "{2}
006001=Fetch-group "{0}" nested in the fetch-group "{1}" was not found in class "{2}"
006002=Maximum FetchDepth cannot be given the value {0}. You must specify either -1 (no limit on fetching) or a positive integer.
006003=Detachment roots cannot be changed once set until commit is reached.
006004=Attempt to add the field "{0}" to a fetch group for the class "{1}", but the field doesnt exist in that class!
#
# Reachability
#
007000=Object "{0}" (id="{1}") lifecycle state "{2}" added to the list of reachables on commit.
007002=Performing reachability on multi-valued (collection/map) relation field "{0}"
007003=Performing reachability on multi-valued (array) relation field "{0}"
007004=Performing reachability on single-valued relation field "{0}"
007005=Could not find StateManager for PC object "{0}" at field "{1}" - ignoring for reachability
007006=Field "{0}" has been specified to not use "cascade-persist". Not persisting this field.
007007=Field "{0}" is being persisted for "cascade-persist".
007008=Field "{0}" has been specified to not use "cascade-update". Not updating this field.
007009=Field "{0}" is being updated for "cascade-update".

#
# NucleusContext
#
008000=DataNucleus Context : Version "{0}" with JRE "{1}" on "{2}"
008003=There is no available API adapter "{0}". Using existing adapter.
008004=There is no available StoreManager of type "{0}". Make sure that you have put the relevant DataNucleus 'store' plugin in your CLASSPATH and if defining a connection via JNDI or DataSource you also need to provide persistence property "datanucleus.storeManagerType"
008005=No available StoreManager found for the datastore URL key "{0}". Please make sure you have all relevant plugins in the CLASSPATH (e.g datanucleus-rdbms?, datanucleus-db4o?), and consider setting the persistence property "datanucleus.storeManagerType" to the type of store you are using e.g rdbms, db4o

008009=The MetaDataManager associated with the API "{0}" is not registered. Please check that you have the relevant plugin in your CLASSPATH.
008010=Error creating the MetaDataManager for API "{0}" : {1}
008011=Property "{0}" specified yet cannot be used since the datastore schema is ReadOnly/Fixed
008012=Property "{0}" specified with value "{1}" but this value is invalid. Please check the documentation for valid values
008013=The properties file "{0}" has already been loaded. Ignoring the newly specified properties file  "{1}"
008014=Could not load property file "{0}"
008015=Property {0} unknown - will be ignored
008016=GenerateSchema : could not run schema generation step since this datastore ("{0}") doesn't support schema operations
008017=Compiling NamedQuery {0} : "{1}"

#
# Connections
#
009000=The Connection was acquired by the developer and must be closed before using the persistence API.
009001=Connection factory ({0}) not supported - must be a javax.sql.DataSource
009002=Connection Factory "{0}" not found
009003=A database connection is already in use for this manager - perhaps a Query is still running ? The JDO spec (12.6) states that a Persistence Manager can have one datastore connection open at any one time. As a result if you want to perform multiple operations you should use mutliple PersistenceManagers
#
# ExecutionContext
#
010000=ExecutionContext "{0}" opened for datastore "{1}" with txn="{2}"
010001=ExecutionContext "{0}" closed
010002=ExecutionContext has been closed
010003=ExecutionContext.internalFlush() process started using ordered flush - {0} enlisted objects
010004=ExecutionContext.internalFlush() process finished
010005=Attempt to access HOLLOW nondurable object via getObjectById!
010006=No nondurable object with this id accessible via the cache - maybe for a different manager?
010007=Object with id "{0}" is managed by a different persistence manager
010008=Object is not detached. The operation requires a detached object.
010009=Detaching object from persistence : "{0}" (depth={1})
010010=Detaching copy of object "{0}" (depth={1}) as "{2}" with detached-fields {3} and fields-to-load={4}
010011=DetachOnClose : Closing manager so detaching all current objects ...
010012=DetachOnClose : completed detach
010013=Unable to detach object "{0}" (id="{1}") on commit since it no longer exists in the datastore. Maybe you have datastore constraints that have deleted it
010014=detachCopy cannot be called outside of a transaction when there are transient instances reachable.
010015=Making object persistent : "{0}"
010016=(Re)attaching object to persistence : "{0}"
010017=Attempt to attach object "{0}" to persistence yet another persistent object with this identity already exists enlisted in this transaction
010018=(Re)attaching object to persistence : "{0}" - attaching to be "{1}"
010019=Deleting object from persistence : "{0}"
010020=Transient instances cant be deleted.
010021=Transient-Transactional instances cant be deleted. Object id = {0}
010022=Making object transient : "{0}"
010023=Object "{0}" (id="{1}") is not transactional
010024=Transient dirty instances can't change to the non transactional state.
010025=Cant call makeNontransactional on Transient non transactional instances
010026=No such object
010027=Failed to find the object of with id "{0}"
010028=Unable to create Object Identity for class when class is null!
010029=Unable to create Object Identity for class "{0}" since key is of an unsupported type ({1})
010030=Error whilst creating new objectId instance of type "{0}" for abstract class "{1}"
010031=Some instances failed to flush successfully due to optimistic verification problems.
010032=Performing check of objects for "persistence-by-reachability" (commit) ...
010033=Object with id "{0}" was reachable when a makePersistent() was called on another object but is no longer reachable (at commit). The object will be removed from the datastore.
010034=Completed check of objects for "persistence-by-reachability" (commit).
010035=Cannot perform operation since ImplementationCreator doesnt exist in the CLASSPATH (put datanucleus-enhancer.jar in the CLASSPATH).
010036=One or more instances could not be evicted
010037=One or more instances could not be refreshed
010038=One or more instances could not be retrieved
010039=One or more instances could not be made persistent
010040=One or more instances could not be deleted
010041=One or more instances could not be made transient
010042=One or more instances could not be made transactional
010043=One or more instances could not be made non-transactional
010044=Unable to find the object with a null id!
010045=Unable to find object with id "{0}" of type "{1}" since this is abstract and you requested no validation
010046=ExecutionContext.internalFlush() process started using optimised flush - {0} to delete, {1} to insert and {2} to update
010047=Object "{0}" was detached before its changes could be flushed. Changes will not reach the datastore. This is likely the result of a JPA detach() call before flush(), which is a stupid thing to do anyway, but it was your choice.

010050=Attempt to start optimistic transaction yet StoreManager for this datastore doesn't support optimistic locking! Set "datanucleus.Optimistic" to false.

#
# Managed Relationships
#
013000=Management of relations : starting
013001=Management of relations : completed
013002=Management of relations : Object "{0}" field "{1}" was changed to "{2}" but field "{3}" of that object was changed to "{4}"! You can disable this check using "datanucleus.manageRelationshipsChecks"
013003=Management of relations : Object "{0}" field "{1}" was changed to "{2}" but field "{3}" of that object was nulled! You can disable this check using "datanucleus.manageRelationshipsChecks"
013004=Management of relations : Object "{0}" has bidirectional field "{1}" currently set to "{2}" but this is now to be related to "{3}" so nulling this field.
013005=Management of relations : Object "{0}" has bidirectional field "{1}" and object "{2}" has just been set to this object, so updating this objects link across to that object.
013006=Management of relations : Object "{0}" has bidirectional field "{1}" and was related to field "{2}" of object "{3}" but now has been changed. Removing it from the container.
013007=Management of relations : Object "{0}" has a bidirectional field "{1}" and is now related to field "{2}" of object "{3}" but isnt in the container. Adding it.
013008=Management of relations : Object "{0}" has a bidirectional field "{1}" and the object "{2}" was added to this field, but it is in deleted state! You can disable this check using "datanucleus.manageRelationshipsChecks"
013009=Management of relations : Object "{0}" has a bidirectional field "{1}" and the object "{2}" was added to this field, but this field has had its owner set to "{3}"! You can disable this check using "datanucleus.manageRelationshipsChecks"
013010=Management of relations : Object "{0}" has a bidirectional field "{1}" and the object "{2}" was removed from this field, but this field has had its owner set to this one! You can disable this check using "datanucleus.manageRelationshipsChecks"

#
# SchemaTool
#
014000=DataNucleus SchemaTool : Creation of the schema
014001=DataNucleus SchemaTool : Deletion of the schema
014002=DataNucleus SchemaTool : Validation of the schema
014003=DataNucleus SchemaTool : Database information
014004=DataNucleus SchemaTool : Schema information
014005=DataNucleus SchemaTool : Classpath
014006=>>  {0}
014007=No valid input (either a set of metadata/class files, or the name of a persistence-unit) was specified!
014008=An error was encountered creating a PersistenceManagerFactory : {0} - please consult the log for more information.
014009=DataNucleus SchemaTool : Input Files
014010=>>  {0}
014011=Reading {0} input (metadata/class) files ...
014012=Completed read of {0} input (metadata/class) files
014013=Error processing class file ("{0}"), converting to a URL. Please check your specification and CLASSPATH
014014=An error was encountered reading the specified input files. Please consult the log for details. The following may help : {0}
014015=DataNucleus SchemaTool : Handling schema for persistence-unit "{0}"
014016=No "persistence.xml" files were found in the CLASSPATH yet you specified as input the name ("{0}") of a "persistence-unit" to use in SchemaTool. You must have a valid "persistence.xml" file in the CLASSPATH in a valid location to use this option.
014017=No "persistence-unit" of name "{0}" was found in the CLASSPATH. Please check the "persistence.xml" files available
014018=Outputting Schema DDL to "{0}" for all specified classes
014019=Outputting Schema DDL to "{0}" for classes which dont have existing schema
014020=DataNucleus SchemaTool : Persistence Properties
014021=No MetaData was encountered to generate the schema!
014022=>>  {0}={1}
014023=DataNucleus : Help
014024=>> SchemaTool [options] [mapping-files] [class-files]
014025=where "options" can be
014026=-create : Create the DB tables for the classes specified by the mapping-files/class-files
014027=-delete : Delete the DB tables for the classes specified by the mapping-files/class-files
014028=-validate : Validate the DB tables for the classes specified by the mapping-files/class-files
014029=-dbinfo : Display the database info (Database version, supported options, datastore types, etc)
014030=-schemainfo : Display the schema info (DDL statements)
014031=-ddlFile <filename> : write all DDL statements to the given file instead of sending them to the DB
014032=-completeDdl : write the DDL for all tables not just the missing ones (when using ddlFile)
014033=-help : Write this message
014034=and "mapping-files" (and classes specified therein) must be present in the CLASSPATH
014035=and "class-files" must be present in the CLASSPATH
014036=DataNucleus SchemaTool : The mode parameter only accepts values of "create", "delete", "validate", "dbinfo", "schemainfo"
014037=An exception was thrown during the operation of SchemaTool. Please refer to the log for full details. The following may help : {0}
014038=Error parsing JDO meta-data files : {0}
014039=No classes specified !
014040=Class {0} not found ! Please check that the class is in the CLASSPATH.
014041=Database driver/URL not specified !
014042=Error : No JDO MetaData files specified !
014043=SchemaTool completed successfully
014044=-delete-create : Delete the DB tables for the classes specified by the mapping-files/class-files and recreate them
014045=DataNucleus SchemaTool : Deletion+Creation of the schema

#
# Transactions
#
015000=Transaction begun for ExecutionContext {0} (optimistic={1})
015001=Transaction committing for ExecutionContext {0}
015002=Transaction rolling back for ExecutionContext {0}
015003=Transaction begun with connection {0}
015004=Transaction failed to start
015005=Transaction failed to flush
015006=Transaction committing with connection {0}
015007=Transaction failed to commit
015008=Transaction rolling back with connection {0}
015009=Transaction failed to commit

015012=Invalid isolation level : {0}
015013=Connection {0} started for pessimistic transaction
015014=Connection {0} closed for pessimistic transaction
015015=Connection {0} started for optimistic transaction
015016=Connection {0} closed for optimistic transaction
015017=Object "{0}" (id="{1}") enlisted in transactional cache
015018=Object "{0}" (id="{1}") enlisted in transactional cache is now enlisted using id="{2}"
015019=Object "{0}" (id="{1}") being evicted from transactional cache
015020=Transaction has been marked as "rollback-only". Commit cannot be performed in this state.
015021=Couldnt obtain a connection.
015022=Transaction committed in {0} ms
015023=Transaction rolled back in {0} ms
015024=Use of JTA transactions requires use of a managed datasource since it relies on the TransactionManager to commit datastore connections.
015025=We have already synchronised with the JTA transaction, yet another request was raised to do this!
015026=User requested JTA transactions yet an error occurred while obtaining the JTA transaction.
015027=JTA transaction is marked for rollback, probably had a timeout. Any subsequent operation requiring a database connection will fail.
015028=Error while trying to interrogate JTA Transaction's status!
015029=JTA transaction required to synchronise with the JTA transaction manager, yet we could not access the NamingService. Please check your environment.
015030=JTA transaction required to synchronise with JTA transaction manager, yet we couldnt find the TransactionManager (only WebLogic, JBoss supported)
015031=A database transaction has been rolled back, but the following exceptions were thrown while transitioning the state of the JDO objects participating in the transaction.
015032=Transaction is already active.
015033=Transaction is already active.
015034=Transaction is still active. You should always close your transactions correctly using commit() or rollback().
015035=Transaction is not active. You either need to define a transaction around this, or run your PersistenceManagerFactory with 'NontransactionalRead' and 'NontransactionalWrite' set to 'true'
015036=Transaction is commiting or rolling back. This operation is not available at the moment.
015037=A database transaction has been committed, but the following exceptions were thrown while transitioning the state of the JDO objects participating in the transaction.
015038=Operation {0} failed on resource: {1}, error code {2} and transaction: {3}
015039=Running {0} operation on resource: {1}, error code {2} and transaction: {3}
015040=Transaction is not active. You need to define a transaction around this
015041=Impossible to perform operation since it either requires an active transaction or 'NontransactionalRead' enabled. You have neither of these.
015042=Impossible to perform operation since it either requires an active transaction or 'NontransactionalWrite' enabled. You have neither of these.
015043=The datastore doesnt support the selected transaction isolation level "{0}"
015044=Exception flushing work in JTA transaction. Mark for rollback. Look at the nested exception for details
015045=Cannot mark transaction for rollback after exception in beforeCompletion. PersistenceManager/EntityManager might be in inconsistent state
015046=Exception during afterCompletion in JTA transaction. PersistenceManager/EntityManager might be in inconsistent state
015047=Received unexpected transaction status "{0}"
015048=Transaction.afterCompletion called on {0} but is already closed. This is likely because you're using a JavaEE container (e.g JBoss) that has closed the EntityManager before calling afterCompletion on the transaction of that EntityManager. The JPA spec is totally inadequate in that it does not define the order of such afterCompletion calls and really should state in BOLD that the EntityManager should only be closed after all JTA afterCompletions have been called; try requesting that of the JPA EG. Any statistics gathering is rendered incorrect as a result.

#
# Types
#
016001=Java type {0} using the support for {1}
016002=Exception thrown in converting "{0}" into object of type "{1}"
016003=Java types support initialising ...
016004=User-defined type mapping class "{0}" was not found. Please check the mapping file class specifications and your CLASSPATH. The class must be in the CLASSPATH.
016005=User-defined SCO wrapper class "{0}" was not found. Please check the mapping file class specifications and your CLASSPATH. The class must be in the CLASSPATH.
016006=Java types support loaded : supported java types={0}
016007=Type converter support initialising ...
016008=Type converter support loaded

#
# Sequence
#
017000=The requested sequence "{0}" could not be found. Please make sure that it is specified in a valid Meta-Data file.
017001=The factory class "{0}" for the sequence "{1}" was not found. Please check that it is in the CLASSPATH.
017002=Error when invoking the static method newInstance() on the factory class "{0}" : {1}
017003=The sequence "{0}" has been created, and uses id generator "{1}"
017004=The sequence "{0}" does not have any values allocated. Please call the "allocate(int)" method first to allocate some values.
017005=The sequence "{0}" does not generate numeric values. Please use the "next()" method to access the Object value.
017006=Error while obtaining connection for value generation : {0}
017007=Error while closing connection for value generation : {0}
#
# Exceptions
#
018000=The class "{0}" is not persistable. This means that it either hasn't been enhanced, or that the enhanced version of the file is not in the CLASSPATH (or is hidden by an unenhanced version), or the Meta-Data/annotations for the class are not found.
018001=The class "{0}" is required to be persistable yet no Meta-Data/Annotations can be found for this class. Please check that the Meta-Data/annotations is defined in a valid file location.
018002=The class "{0}" is not persistable. This means that it either hasn't been enhanced, or that the enhanced version of the file is not in the CLASSPATH (or is hidden by an unenhanced version), or the Meta-Data for the class is not found.
018003=The class "{0}" is required to be persistable yet no Meta-Data can be found for this class. Please check that the Meta-Data is defined in a valid file location for JDO.
018004=The class "{0}" is not Detachable. This means that the MetaData for the class did not have the "detachable" attribute set to true.
018005=Some of the specified objects are of classes that are not Detachable. This means that the MetaData for the classes did not have the "detachable" attribute set to true. The nested exceptions contains the details for these objects.
018006=Object of type "{0}" is detached. Detached objects cannot be used with this operation.
018007=Persistent class "{0}" has no extent (defined in the Meta-Data). Please check the specification of the MetaData for this class is you require an Extent.
018008=Field "{0}" contains a persistable object that isnt persistent, but the field doesnt allow cascade-persist!
018009=Field "{0}" does not exist in {1} or is not persistent
018010=Field number {0} does not exist in {1} or is not persistent
#
# Primary Key
#
019000=Class "{0}" has been specified with an object-id class {1} which is an inner class but is not static. The ObjectId class MUST be sttaic if it is defined as an inner class.
019001=Class "{0}" has been specified with an object-id class {1} which is not public. The ObjectId class MUST be public.
019002=Class "{0}" has been specified with an object-id class {1} which is not Serializable. The ObjectId class MUST be Serializable.
019003=Class "{0}" has been specified with the JDO SingleFieldIdentity object-id class, but there are more than 1 primary key field specified for the class. Only one field can be specified as primary key.
019004=Class "{0}" has been specified with an object-id class {1} which doesn't have a default constructor. All objectId classes MUST have a default constructor.
019005=Class "{0}" has been specified with an object-id class {1} which doesn't have a String constructor. All objectId classes MUST have a String constructor.
019006=Class "{0}" has been specified with an object-id class {1} which doesn't override the toString() method. All objectId classes MUST override the toString() method.
019007=Class "{0}" has been specified with an object-id class {1} which doesn't override the hashCode() method. All objectId classes MUST override the hashCode() method and return a value based on the values of all PK fields.
019008=Class "{0}" has been specified with an object-id class {1} which doesn't override the equals() method. All objectId classes MUST override the equals() method and return a value based on the values of all PK fields.
019009=Class "{0}" has been specified with an object-id class {1} which has a field {2} which isn't Serializable. All non static fields of an objectId class must be serializable.
019010=Class "{0}" has been specified with an object-id class {1} which has a field {2} which isn't public. All non static fields of an objectId class must be public.
019011=Class "{0}" has been specified with an object-id class {1} which has a field {2}, but this field was not found in Class {0}.
019012=Class "{0}" has been specified with an object-id class {1} which has a field {2}. The field {0}.{2} has type {3} which is persistence capable. All non static fields of an objectId class must include the names of the primary key fields in the JDO class, and the types of the corresponding fields must be identical.
019013=Class "{0}" has been specified with an object-id class {1} which has a field {2}. The field {1}.{2} has type {3} but should be {4}. All non static fields of an objectId class must include the names of the primary key fields in the JDO class, and the types of the corresponding fields must be identical.
019014=Class "{0}" has been specified with an object-id class {1} which has a field {2}. The field {1}.{2} has type {3} that must be specified in the metadata /jdo/package/class/@objectid-class attribute for type {4}. e.g <class name="{4}" objectid-class="{3}"/>
019015=Class "{0}" has been specified with an object-id class {1} which has {2} fields, whereas the class has been defined with {3} fields in the primary key. The number of fields in the objectidClass and the number in the primary key must concur.
019016=Class "{0}" has invalid primary key class {1}.

#
# Schema Mapping, columns etc
#
020185=Field "{0}" should be using "subclass-table" inheritance strategy yet isnt. Please report this.
020186=Field "{0}" is declared type requiring multiple FKs and has had its column(s) specified, however the number of columns specified ({1}) is not the same as the number of possible FKs for this field ({2}).
020187=Added column for type "{0}" for field "{1}" (field declared as using subclass-table)
020188=Added column for type "{0}" for field "{1}" (field declared as reference type - interface/Object)
020189=Field "{0}" is defined as a reference type (interface or Object) and was specified as being implemented by class "{1}" but this class was not found!
020190=Field "{0}" is defined as a reference type (interface or Object) ("{1}") and was specified as being implemented by class "{2}" but this is an interface!

#
# Query
#
021000=Incompatible query element type : was {0}, but must be {1} or a subclass
021001=The query returned more than one instance BUT either unique is set to true or only aggregates are to be returned, so should have returned one result maximum
021002=Invalid import declaration : {0}
021003=Invalid package import : {0}
021004=Duplicate class import found for {0}
021005=Class named in imports not found : {0}
021006=Caching the fact that {0} was not found by {1}
021007=Array types are illegal here : {0}
021008=Ambiguous class declaration, could be {0} or {1}
021009=Candidate class "{0}" not found
021010=Class {0} was resolved to be {1}. It wasn't defined fully-qualified so had to be looked up; you can avoid the lookup (and improve performance) by fully-qualifying the class in the query.
021011=Attempt to invoke method "{0}()" on object of type "{1}" - not supported for this datastore
021012={1} Query : Processing the "{0}" clause using in-memory evaluation (clause = "{2}")
021013=Manager that was used to generate the Query is closed!
021014=This query is in an unmodifiable state. It's structure cannot be changed
021015=The Query contains a class-name "{0}" (candidate class, result class, parameter, or variable) yet this cannot be resolved. Please check the name, and the imports for the Query.
021016=Query contains access of "{0}" yet this field/property doesn't exist
021017=Query has no associated Manager
021018=Execution of the query "{0}" was not completed before the timeout of {1}ms
021019=Starting query "{0}" in separate thread with timeout of {1}ms
021020=Query "{0}" has been cancelled
021021=An error has occurred executing the query "{0}"
021022=Starting query "{0}" in separate thread with no timeout
021023=Evaluation of filter for candidate="{0}" gives a match
021024=Evaluation found variable="{0}" not set, and should take values from "{1}"
021025=Evaluation being attempted for variable="{0}" with value of "{1}"
021026=Evaluation has processed all values of variable="{0}" so removing its value
021027=Query has been specified to delete persistent objects, yet ordering has been specified. You cannot specify the ordering on such a deletion query.
021028=Query has been specified to delete persistent objects, yet grouping has been specified. You cannot specify the grouping on such a deletion query.
021029=Query has been specified to delete persistent objects, yet the result has been specified. You cannot specify the result on such a deletion query.
021030=Query has been specified to delete persistent objects, yet the resultClass has been specified. You cannot specify the resultClass on such a deletion query.
021031=Query has been specified to delete persistent objects, yet the result range has been specified. You cannot specify the result range on such a deletion query.
021032=Query has been specified with "unique" and to delete persistent objects, however the query implies the deletion of more than 1 object. You should remove the "unique" specification if you want to delete these objects.

021034=Dont currently support queries of language "{0}" for datastore "{1}"

021038=This implementation of JDOQL doesn't yet support bulk updates
021039=This implementation of JDOQL doesn't yet support bulk deletes
021040=This implementation of JPQL doesn't yet support bulk updates
021041=This implementation of JPQL doesn't yet support bulk deletes
021042=Exception thrown when executing query
021043=Error encountered when extracting results for query "{0}"
021044={0} Query : Compiling "{1}"
021045={0} Query : Compile Time = {1} ms
021046={0} Query : Executing "{1}" ...
021047={0} Query : Error during execution of "{1}" : {2}.

021048=No candidate class provided for {0} query
021049=Unable to find the field "{0}" in the candidate class. It is possible that this field is a field in a subclass, but it is illegal to reference fields directly when they are in a subclass.
021050=Query filter "{0}" doesn't yield a boolean result
021052={0} query contains the identifier "{1}", yet this is a keyword. The query is invalid.
021053=Class "{0}" is used in a cast operation in a query yet could not be found. Please make sure that this class is contained in the CLASSPATH and it's declared in query imports.
021054=The {0} query contains an invalid expression
021055=Query has had some parameter(s) declared ("{0}"), yet also has at least 1 implicit parameter ("{1}"). This is invalid. Parameters must either be all explicit (declared), or all implicit (specified using a : prefix).
021056=Query has been specified with an implicit parameter "{0}" (parameter position {1}) yet there is no parameter value specified for this when the query was executed!
021057=Use of "new" in {0} queries must be followed by a valid class name, yet {1} is not found. Please check the imports for this query.
021058=Use of "new" in {0} queries must be followed by a class name and the constructor arguments, yet isn't in "{1}"
021060=Error binding "{0}" to "{1}" since it was previously bound to "{2}".
021061=Variable "{0}" has not been bound to the query!

021064=The range {0} expression accepts only Literal values. Either define it as parameter or a literal. The current value is {1}.
021065=The range {0} expression expects a number, but it currently is {1}.
021066=Unable to find the class for "{0}". Please check that this class is accessible in the CLASSPATH.
021068=Parameter for query ("{0}") is bound to a different manager than this query!
021069=The ordering has a field expression "{0}" that doesnt appear in the grouping. Any ordering specification has to be present in the grouping when grouping is specified
021070=The result clause has a field expression "{0}" that doesnt appear in the grouping. Any result specification has to be present in the grouping when grouping is specified
021071=The having clause has a field expression "{0}" that doesnt appear in the grouping. Any having specification has to be present in the grouping when grouping is specified
021072=Candidates collection specified for query is null.
021074={0} Query : Execution Time = {1} ms
021075=Not caching the datastore compilation since some parameters are evaluated during the compilation and aren't present in the final datastore-specific query

021079=Query "{0}" of language "{1}" has been run before so reusing existing generic compilation
021080=Query "{0}" of language "{1}" for datastore "{2}" has been run before so reusing existing datastore compilation
021081=Query "{0}" when executed had {1} results. These are being cached.
021082=Query "{0}" was found in the query results cache with {1} results. Using those

021083={0} Query : Compiling "{1}" for datastore
021084={0} Query : Compile Time for datastore = {1} ms
021085={0} Query compiled to datastore query "{1}"

# Query : Parameters/Variables
021101=Query has an invalid parameter list "{0}"
021102=Query has an illegal parameter name "{0}"
021103=Query has a duplicate parameter name "{0}"
021104=Query has an invalid variable list "{0}"
021105=Query has an illegal variable name "{0}"
021106=Query has a variable name "{0}" which conflicts with a parameter name
021107=Query has a duplicate variable name "{0}"
021108=Query requires {0} parameters, yet {1} values have been provided.
021109=The parameter {0} expected the argument value of primitive type {1}.
021110=The {0} query requires a parameter "{1}" yet this hasn't been provided.
021111=Query has had some variable(s) declared ("{0}"), yet also has at least 1 implicit variable ("{1}"). This is invalid. Variables must either be all explicit (declared), or all implicit.
021112=Query has been specified with an implicit parameter "{0}" yet there is no parameter value specified for this when the query was executed!
021113=Query has had the value specified for an implicit parameter "{0}" yet this parameter doesnt exist in the query itself!
021114=Query has parameter "{0}" represented as a {1} yet is being compared to a {2}. Parameter values should be consistent with what they are compared with
021115=Query has subquery defined but the variable declaration is null! A subquery has to pass its value across to the main query via a variable
021116=Query has parameter "{0}" supplied at execution yet the query doesnt make use of this parameter
021117=Query has parameter "{0}" defined as "{1}" but is supplied as null!
021119=Query has parameter "{0}" defined yet it has not been supplied to the query execute() method

# Query : Result
021201=The Query will return multiple fields yet the ResultClass has been set to a simple type ({0}). These are inconsistent.
021202=The Query will return a single field but it is not of a consistent type as the ResultClass ({0}) : It is {1}
021203=Query was required to return objects of type "{0}" yet it was impossible to create objects of this type. Check that the result class is valid for JDO.
021204=Query needs to return objects of type "{0}" but it was impossible to set the field "{1}" type "{2}". The field should have either a public set/put method, or be public.
021205=Query needs to return objects of type "{0}" but it was impossible to create a new instance of this type. The result class needs a no-args constructor.
021206=Result Class "{0}" doesnt have a public constructor with args of types {1}
021207=Result Class "{0}" doesnt have a public method "void {1}({2})".
021208=Result Class "{0}" doesnt have a public method "void {1}(Object, Object)".
021209=Result Class "{0}" doesnt have a public field "{1}"
021210=Result Class query field names are not case sensitive. It does not allow fields with same name, but in a different case. For instance, the field "{0}" is conflicting.
021211=Query has a result field "{0}" of type "{1}" yet the field in the result class has type "{2}"
021212=Query defines a result class "{0}" but there is no way of setting the field "{1}"

# Query Cache
021500=Query Cache "{0}" is not registered. Please check your CLASSPATH and specification.
021501=Query Cache "{0}" is registered to use class "{1}" yet this is not found. Please check your CLASSPATH and plugin specification.
021502=Query Cache of type "{0}" initialised

#
# Api Adapter
#
022000=Error : An error occurred trying to instantiate an instance of the API adapter "{0}" (perhaps you don't have the requisite datanucleus-api-XXX jar in the CLASSPATH, or the 'api' jar for the persistence spec you are using?) : {1}
022001=Error : Could not find API definition for name "{0}". Perhaps you don't have the requisite datanucleus-api-XXX jar in the CLASSPATH?

#
# SCO
#
023000=Incompatible type requested for field "{0}" : was {1} but should be {2}
023001=Nulls are not allowed for field "{0}" in object "{1}"
023002=SCO Collection/Map is not queryable since it is not currently owned by any first-class object.
023003=Created SCO wrapper for object "{0}" field "{1}" with {2} entries, using options="{3}"
023004=Object "{0}" field "{1}" is replaced by a SCO wrapper of type "{2}" {3}
023005=Object "{0}" field "{1}" flushing changes to the datastore
023006=Object "{0}" field "{1}" loading contents to SCO wrapper from the datastore
023007=Object "{0}" field "{1}" is having its SCO wrapper initialised with a container with {2} values
023008=Object "{0}" field "{1}" is having its SCO wrapper updated with a container with {2} values
023009=Can't write object "{0}" since it is managed by a different persistence manager
023010={0} is an invalid SCO type for field {1}, must be compatible with {2}
023011=Class {0} (declared type of field {2} referencing {1}) is not supported as a Second-Class object
023012=The field "{0}" has been specified to use a comparator of type "{1}" yet this class was not found in the CLASSPATH. Please check the name of the comparator class specified in the MetaData.
023013=Execution of method "{0}" on field "{1}" caused an error : {2}
#
# Plugin
#
024000=File {0} doesn't exist. Check your path or classpath.
024001=Error reading plug-in file {0} : {1}
024002=Extension Point "{0}" not registered, but plugin "{1}" defined in {2} refers to it.
024003=Loading extension points from plug-in file {0}.
024004=Loading extensions from plug-in file {0}.
024005=Plugin Registry "{0}" not found. Falling back to DataNucleus registry

024007=Error registering Bundle since URL to manifest.mf is null
024008=Error reading manifest file "{0}"
024009=Plugin (Bundle) "{0}" is already registered. Ensure you dont have multiple JAR versions of the same plugin in the classpath. The URL "{1}" is already registered, and you are trying to register an identical plugin located at URL "{2}."
024010=Error creating URL for plugin MANIFEST file "{0}"
024011=Error reading MANIFEST.MF for "{0}"
024012=Could not find MANIFEST.MF file for plugin file "{0}" so ignoring it
024013=Bundle "{0}" has an optional dependency to "{1}" but it cannot be resolved
024014=Bundle "{0}" requires "{1}" but it cannot be resolved.
024015=Bundle "{0}" requires "{1}" version "{2}" but the resolved bundle has version "{3}" which is outside the expected range.
024016=Error creating DocumentBuilder to parse XML file : {0}
#
# CallbackHandler
#
025000=Error : An error occurred trying to instantiate an instance of the CallbackHandler "{0}" : {1}
025001=An exception was thrown from the user callback "{0}".
#
# StateManager
#
026000=Insufficent access granted to org.datanucleus.*
026001=Disconnecting clone {0} from {1}
026002=No such field {0} in class {1}
026003=Attempted to replace the StateManager with a different one
026004=Attempted to clear the StateManager then disconnect
026005=Clearing StateManager for {0}
026006=Method not supported
026007=Cannot share owned second-class objects, object owned by field {0} of object {1}
026008=deletePersistent() called recursively
026009=flush() called recursively
026010=Object is marked as dirty yet no fields are marked dirty
026011=Disconnecting {0} from {1}
026012=Specified class {0} is not persistable
026013=No such object (identity="{0}")
026014=Failed to find the object of class "{0}" with id "{1}"
026015=Class {0} not found ! Please check that the class is in the CLASSPATH.
026016=The primary-key field {0} is null.
026017=An object of class "{0}" uses SingleFieldIdentity using the field "{1}" yet this field has not had its value set! Either set the field manually, or set a value-strategy for that field.
026018=Class "{0}" has not been registered. Please check that it is enhanced.
026019=Cannot create new instance of class "{0}". If this is an abstract class, make sure you don't have a row for that class in the database without a corresponding row in any concrete subclass table.
026020=Field "{0}" has been specified with a value-strategy of "{1}" but the field is of an invalid type.
026021=Field "{0}" of object "{1}" has been registered for updating when its value PC object ("{2}") is inserted into the datastore.
026022=Field "{0}" of object "{1} is being updated now that its value PC object ("{2}") is inserted in the datastore.
026023=Object of type "{0}" and identity "{1}" cannot be detached since it is already in deleted state!
026024=Object of type "{0}" and identity "{1}" cannot be detached since it is already detached!
026025=Object of type "{0}" and identity "{1}" was not detached correctly. Please consult the log for any possible information.
026026=Object "{0}" is being deleted since the field ({1}) where it was the value has just been nulled and the field is delete-dependent.
026027=An illegal "{0}" transition was attempted from the "{1}" state, sm = "{2}"
026028=Object "{0}" has been marked for persistence but its actual persistence to the datastore will be delayed due to use of optimistic transactions or "datanucleus.flush.mode" setting
026029=Object "{0}" (id="{1}") is having the value in field "{2}" replaced by a SCO wrapper
026030=Object "{0}" (id="{1}") is having the SCO wrapper in field "{2}" replaced by the unwrapped value
026031=Object "{0}" (id="{1}") is to be detached (using DetachAllOnCommit?) but is not detachable, so being made transient
026032=Object "{0}" (id="{1}") has a non-detached value in field {2} that is outside the range of the FetchPlan. Unloading it.
026033=Object "{0}" (id="{1}") is having the following fields in Level 2 cache object updated : {2}
026034=Object "{0}" (id="{1}") is loading the following fields from the Level 2 cache object : {2}
#
# LifeCycle states
#
027000=Cant read fields outside of transactions. You may want to set 'NontransactionalRead=true'.
027001=Cant write fields outside of transactions. You may want to set 'NontransactionalWrite=true'.
027002=Cant read fields outside of transactions. You may want to set 'NontransactionalRead=true'.
027003=Cannot make object non-transactional since object is new, deleted and not yet committed
027004=Cannot make object transient since object is new, deleted and not yet committed
027005=Cannot read fields from a deleted object
027006=Cannot write fields to a deleted object
027007=Cannot make object non-transactional since object has been deleted
027008=Cannot make object transient since object has been deleted
027009=Cannot read fields from a deleted object
027010=Cannot write fields to a deleted object
027011=Cannot make object non-transactional since object is dirty
027012=Cannot make object transient since object is dirty
027013=Cannot make object non-transactional since object is new and not yet committed
027014=Cannot make object transient since object is new and not yet committed
027015=Field not copied to the detached instance. Add to your FetchPlan this field and detach the object.
027016=Object "{0}" (id="{1}") has a lifecycle change : "{2}"->"{3}"
#
# XML Parser
#
028000=XML Entity Public="{0}" System="{1}" : using local source "{2}"
028001=XML Entity Public="{0}" System="{1}
028002=resolveEntity({0}, {1}) could not be found
028003=resolveEntity({0}, {1}) failed!
#
# SingleFieldIdentity
#
029000=Impossible to construct a SingleFieldIdentity of type "{0}" since the class passed is null.
029001=The id type passed to construct a SingleFieldIdentity for class "{0}" is null.
029002=The id type ("{0}") passed to construct a SingleFieldIdentity for class "{1}" is invalid.
029003=The key value passed to construct a SingleFieldIdentity of type "{0}" for class "{1}" is null.
029004=The key value passed to construct a SingleFieldIdentity of type "{0}" for class "{1}" is of an incorrect type ("{2}") - should be "{3}".
#
# Utils
#
030000=Still waiting for read lock on {0}
030001=Thread already holds a read lock
030002=Still waiting for write lock on {0}
030003=Bad timestamp format: "{0}" - must be yyyy-mm-dd hh:mm:ss.fffffffff
030004=Missing constructor in class {0}, parameters {1}
030005=Failed attempting to access class {0}
030006=Failed instantiating a new object of type {0}
030007=Unexpected exception thrown by constructor for {0}, {1}
#
# RDBMS Views/Macros
#
031000=Unmatched braces for identifier macro: {0}
031001=Unmatched question marks for parameter macro: {0}
031002=Cannot parse identifier macro: {0}
031003=A circular dependency exists between views : 

#
# Store Manager
#
032000=No Store Manager is available for this JDO implementation : {0}
032001=Managing Persistence of {0}
032002=Unmanaging Persistence of all classes
032003=Managing Persistence of {0} since it was managed previously

032004=Insert/Update/Delete of object "{0}" for read-only datastore! You should make this datastore read-write if you want to modify objects
032005=Insert/Update/Delete of object "{0}" into read-only datastore will be ignored.
032006=Insert/Update/Delete of object "{0}" for read-only class! You should make this class read-write if you want to modify objects
032007=Insert/Update/Delete of object "{0}" for read-only class will be ignored.

032010=Delete dependent of object "{0}" from read-only datastore! You should make this datastore read-write if you want to delete objects
032011=Delete dependent of object "{0}" from read-only datastore will be ignored.

032012=The class "{0}" is tagged as "embedded-only" so does not have its own datastore table.
032013=The class "{0}" is using subclass-table strategy and no subclass/superclass has defined a table.
032014=The class "{0}" is using {1} strategy and no table were found to persist the object.
032015=Attempt to retrieve table name for null class !

032016=Object "{0}" (id="{1}") has been changed in the datastore since your last read. Datastore record has version "{2}" whereas your transaction is using version "{3}"
032017=Class "{0}" has been defined with optimistic version strategy of "{1}" yet this is not supported by DataNucleus currently. Please consult the documentation for supported optimistic strategy values

032018=Registered transactional connection factory under name "{0}"
032019=Registered nontransactional connection factory under name "{0}"

032020=StoreManager : "{0}" using the URL "{1}" - options={2}, {3}

#
# Extent
#
033000=Extent cannot be created for class because the class name hasn't been specified.
033001=Extent cannot be created for class "{0}" because no Meta-Data was found for this class.
033002=Extent of {0} include_subclasses={1}
033003=Query over Extent will never return results without including subclasses : extent= {0}, class={1}

#
# Auto Starter
#
034000=Error starting up DataNucleus : a class "{0}" was listed as being persisted previously in this datastore, yet the class wasn't found. Perhaps it is used by a different DataNucleus-enabled application in this datastore, or you have changed your class names.
034001=Deleting class {0} from list of persistence-managed classes
034002=Unknown Error during auto starter execution. : {0}
034003=Illegal state of AutoStart, disabling it. To enable it, resolve earlier errors.
034004=Error starting up DataNucleus : a class "{0}" was listed as being persisted previously for this datastore yet no MetaData was found for this class.
034005=AutoStart Mechanism "{0}" starting
034006=AutoStart Mechanism "{0}" completed

034100=Class based auto-start. You provide a list of classes to load up when initialising the PMF.

034150=MetaData based auto-start. You provide a list of metadata files to load up when initialising the PMF.

034200=XML file based auto-start. Stores definition in an XML file
034201=XML AutoStarter file {0} doesn't exist. Creating it ...
034202=Error reading XML AutoStarter file {0} : {1}
034203=Error writing XML AutoStarter file {0} : {1}
034204=resolveEntity({0}, {1})

#
# Store Data
#
035000=MetaData cannot be null : table = {0}
035001=Table cannot be null
035002=Class : {0}
035003=Field : {0}
035004=Class : {0} [Table : {1}, InheritanceStrategy : {2}]
035005=Field : {0} [Table : {1}]

#
# Datastore Adapter
#
036000=Missing constructor {0}(ClassBaseTable,int)
036001=Fields of type {0} not (yet) supported
036002={0} can only be used with a persistence-capable field
036003=Datastore Mapping mappings have been defined to be in file "{0}" yet this file can't be found in the classpath.

#
# JDOQL Expressions
#
037000=Cannot perform navigation on field "{0}" in "{1}". Cast the interface to a concrete type and then access the field.
037001=Query has been specified to refer to field "{0}", but the query table "{1}" in use doesn't have a column for this field
037002=Query has been specified to refer to field "{0}" has been specified, but the subfield "{1}" doesnt exist in base field "{2}"
037003=Query has been specified to compare with an object "{0}" which has no JDO identity - maybe the object is transient or embedded. This will always return no instances.
037004=Query has been specified to compare a collection with a non-null value. DataNucleus doesn't currently support this.

037005=Query has been specified to refer to the field "{0}" yet this field relates to a class using "subclass-table" inheritance strategy, and has no possible subclasses with their own tables. A JDOQL query cannot be formed in this situation.
037006=Query has been specified to refer to the field "{0}" yet this field relates to a class using "subclass-table" inheritance strategy. DataNucleus only currently supports a 1-1 relation to a "subclass-table" class when there is only one subclass possible, but here there are more than 1! DataNucleus will use "{1}"
037007=Attempt to compare the instanceof an object and compare it to an expression of type "{0}". JDOQL only allows comparison with a class.

037008=Attempt to invoke the method "{0}" on the class "{1}", yet the method is not public static final. This isnt supported in JDOQL.
037009=Attempt to invoke the method "{0}" on the class "{1}", yet this method doesnt exist!
037010=JDOQL operator "instanceof" has been specified with class "{0}", yet this class is not found. Please check your CLASSPATH!

037011=Attempt to invoke the aggregate expression "{0}" with an argument that is not numeric. This expression can only be used with an argument that has numeric type.
037012=Attempt to use DISTINCT with the aggregate expression "{0}". This is invalid.

037013=JDOQL query has been specified with a new object expression for a constructor for class "{0}" that doesnt exist! Please correct the query.
037014=Attempt to create new object from JDOQL query with "{0}" values yet "{1}" are required
037015=Error occurred when creating new instance of "{0}" : {1}

037016=Query has been specified with instanceof for "{0}" which is not a known class name
037017=Query has been specified with cast for "{0}" which is not a known class name

#
# OID
#
038000=Invalid OID string value : {0}
038001=Identity "{0}" is assigned to class "{1}", but it's not the correct object-id type for this class.
038002=Generated value for field "{0}" using strategy="{1}" (Generator="{2}") : value={3}
038003=Invalid Id generated for field {0}, id : {1}
038004=There is no available value generator for strategy "{0}" for this datastore. Please consult the documentation for details of which generators are available.
038005=Field "{0}" has been specified to use a TableGenerator but none was found with name "{1}"
038006=Field "{0}" has been specified to use a SequenceGenerator but none was found with name "{1}"

#
# Identifiers
#
039000=Case Identifier "{0}" is not supported. Please choose a supported case
039001=Identifier Factory required identifiers in "{0}" but datastore adapter doesnt support this exactly, so using "{1}" instead
039002=Identifier Factory requires identifiers in "{0}" but this is impossible with the current datastore adapter.
039003=Identifier Factory with name "{0}" is not registered! Please check your CLASSPATH for presence of the plugin containing this factory, and your PMF settings for identifier factory.
039004=Identifier Factory "{0}" is registered to use class "{1}" yet this class is not found. Please check the plugin specification and the CLASSPATH
039005=Identifier Factory "{0}" has thrown an error upon construction. Please check the validity of the IdentifierFactory plugin.

#
# Value Generators
#
040000=Unable to create generator for ids of type "{0}" : {1}
040001=Creating ValueGenerator instance of "{0}" for "{1}"

040002=Repository of unique IDs is not valid.
040003=Error encountered allocating block of IDs : {0}
040004=Reserved a block of {0} values
040005=Creating Repository for IDs in the datastore
040006=Invalid value for key-cache-size = {0}
040007=Invalid value for sequence = {0}
040008=Error encountered allocating IDs : {0}
040009=The generator "{0}" does not generate numeric values. Please use the "next()" method to access the Object value.

040010=Could not create new "sequence" {0} since autoCreate flags do not allow it.
040011=Could not create "increment"/"table" value-generation container {0} since autoCreate flags do not allow it. 

#
# Mapping
#
041017=Can't set Application ID parameter. Parameter = {0}

041019=Object "{0}" has bidirectional field "{1}" currently set to "{2}" but this object is being deleted so nulling this field
041021=Object "{0}" has field "{1}" with an N-1 bidirectional relation set to relate to "{2}" but the collection at "{3}" doesn't contain this object so adding it for consistency.

041024=Failure creating an object of class "{0}" : {1}
041025=Impossible to query a collection/map field ("{0}") when it is serialised. Either change your query, or change the field to not be serialised.

041026=Impossible to query an array field ("{0}") when it is stored in a single column. Either change your query, or change the field to not be stored like this.

041027=Can't set BigInteger parameter : value = {0}
041028=Can't get BigInteger result : param = {0}
041029=Can't set BigDecimal parameter : value = {0}
041030=Can't get BigDecimal result : param = {0}

041031=Can't set Object parameter : value = {0}
041032=Can't get Object result : param = {0}

041033=Can't get URL result : param = {0}, value = {1}

041035=Failed to retrieve OID for object

041036=Error creating AID of type {0} : exception is {1}
041037=Error creating AID of type {0}, field {1}, value {2} : exception is {3}
041039=Cannot create SingleFieldIdentity type since the key value retrieved from the datastore is NULL!

041040=Field "{0}" is specified as serialised. DataNucleus doesnt currently support the persistence of serialised Interface fields.
041041=Field "{0}" is specified as embedded. DataNucleus doesnt currently support the persistence of embedded Interface fields.

041043=Field "{0}" is specified as an Object (non-serialised). DataNucleus doesnt currently support the persistence of non-serialised Object fields.

041045=resolveEntity({0}, {1})

041046=Datastore Mapping mappings have been defined to be in file "{0}" yet this file doesnt exist.
041047=Datastore Mapping mappings are defined to be in file "{0}" but there was an error reading this file : {1}
041048=Datastore Mapping mapping class "{0}" was not found. Please check the mapping file class specifications and your CLASSPATH. The class must be in the CLASSPATH.
041049=Datastore Mapping mappings have been defined to be in file "{0}" yet this file can't be found in the classpath.

041051=Failure in call to "{0}" for value "{1}" for column "{2}" : {3}

#
# JDOQL
#
042000=Extent not queryable for class {0}
042001=No candidate class provided for JDOQL query
042002=The JDOQL query filter "{0}" doesn't yield a boolean result
042003=The JDOQL query order "{0}" is invalid
042004=The JDOQL query order "{0}" direction is invalid. Should be either "ascending" or "descending".
042005=The JDOQL query includes a parameter "{0}" yet this hasn't been declared in the parameters.
042006=The JDOQL query requires {0} parameters, yet only {1} have been provided.
042007=Error executing JDOQL query "{0}" : {1}.
042008=Query ("{0}") has been specified with an assignment ("=") yet this is invalid in JDOQL. Perhaps you meant to use '==' to compare two objects ?
042009=Query contains the identifier "{0}", yet this is a JDOQL keyword. The query is invalid.

042010=JDOQL Single-String with "{0}"
042011=Query contains a JDOQL keyword ("{0}") that is out of order. Keywords can only be used in a defined order.
042012=JDOQL Single-String query should always start with SELECT
042013=JDOQL Single-String query has been specified with keyword "{0}" but with illegal following value "{1}"
042014=JDOQL Single-String query has been specified with keyword "{0}" but has no value specified. Should have "{1}" specified after "{0}".
042015=JDOQL Single-String expects the keyword "{0}" after the keyword "{1}"
042016=JDOQL Single-String query has been specified with a class "{0}" which could not be found. Please make sure that this class is contained in the CLASSPATH
042017=JDOQL Single-String query has a subquery clause without a closing parenthesis.

#
# JPQL
#
043000=JPQL Single-String with "{0}"
043001=JPQL Query contains a keyword ("{0}") that is out of order. Keywords can only be used in a defined order.
043002=JPQL Query should always start with SELECT/UPDATE/DELETE
043003=JPQL Query has been specified with keyword "{0}" but with illegal following value "{1}"
043004=JPQL Query has been specified with keyword "{0}" but has no value specified. Should have "{1}" specified after "{0}".
043005=JPQL Query expects the keyword "{0}" after the keyword "{1}"
043006=JPQL Query has been specified with a class "{0}" which could not be found. Please make sure that this class is contained in the CLASSPATH
043007=JPQL UPDATE/DELETE query cannot have GROUP BY clause
043008=JPQL UPDATE/DELETE query cannot have HAVING clause
043009=JPQL UPDATE/DELETE query cannot have ORDER BY clause
043010=JPQL UPDATE query has no update clause! Query should be like "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"
043011=JPQL UPDATE query has update clause but no SET component. Query should be like "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"

#
# MetaData
#
044001=Class "{0}" field "{1}" : metadata has attribute "{2}" defined with value "{3}" yet only accepts "{4}"
044002=MetaData extension "{0}" has valid values of "{1}" but is set to "{2}"!
044003=Class "{0}" field "{1}" : Has a Collection yet no element type is provided in MetaData nor is inferrable using generics, so using Object
044004=Class "{0}" field "{1}" : Has a Map yet no key/value types are provided in MetaData nor is inferrable using generics, so using Object

044005=MetaData Management : Loading Metadata for metadata files "{0}" ...
044006=MetaData Management : Loading Metadata for classes "{0}" ...
044007=MetaData Management : Loading Metadata for persistence-unit "{0}" ...
044008=MetaData Management : Loading Metadata from user ...
044009=MetaData Management : Load of Metadata from the jar file "{0}" ...
044010=MetaData Management : Load of Metadata complete
044011=Cannot create Scanner for metadata, unsupported value type: {0}
044012=Cannot instantiate Scanner: {0}
044013=MetaData Management : Initialising for specified MetaData files and classes
044014=MetaData Management : Initialisation for specified MetaData files and classes complete
044015=MetaData file "{0}" does not contain valid MetaData!
044016=Errors were encountered when loading the specified MetaData files and classes. See the nested exceptions for details
044017=Class "{0}" has no MetaData or annotations.

044018=Populating all MetaData ...
044019=Initialising all MetaData ...
044020=Errors were encountered when initialising the specified MetaData. See the nested exceptions for details

044021=MetaData Management : Initialising for the persistence-unit "{0}"
044022=MetaData Management : Initialisation for persistence-unit "{0}" complete
044023=Errors were encountered when loading the MetaData for the persistence-unit "{0}". See the nested exceptions for details
044024=Errors were encountered when loading the MetaData for the jar-file "{0}". See the nested exceptions for details

044026=Class "{0}" found to be part of persistence-unit "{1}" so loading it in case it is persistable
044027=Persistence-Unit "{0}" has a reference to mapping-file "{1}" but it was impossible to read it - {2}
044028=MetaData handler plugin "{0}" was not found. Please check your CLASSPATH and plugin specification.
044029=Error creating handler of type "{0}" for metadata parsing : {1}
044030=Parsing MetaData file "{0}" using handler "{1}" (validation="{2}")

044031=Attempt to parse file which was null!
044032=Error opening the Meta-Data file "{0}"
044033=Error reading the Meta-Data input "{0}"

044036=Tag "{0}" cannot have the parent tag "{1}" : should be {2}
044037=Unknown tag : "{0}"
044038=MetaData Parser encountered an error in file "{0}" at line {1} : {2} - Please check your specification of DTD and the validity of the MetaData XML that you have specified.
044039=MetaData Parser encountered an error in file "{0}" at line {1}, column {2} : {3} - Please check your specification of DTD and the validity of the MetaData XML that you have specified.
044040=Parser error with file "{0}" has cause {1}
044041=A value is expected in the attribute "{0}" for "{1}" in element "{2}". 

044042=An error occurred while parsing <"{0}"> nested within "{1}" for URI "{2}"

044043=Registering class "{0}" as not having MetaData.
044044=Deregistering class "{0}" as not having MetaData - metadata now being added
044045=The file "{0}" contains metadata of type "{1}" but ought to contain metadata of type "{2}". Ignoring it.
044046=No "persistence.xml" file was found in the CLASSPATH. These files should be found under the META-INF/ directory in the root of a CLASSPATH entry/jar.
044047=Persistence-Unit "{0}" was not found in the available "persistence.xml" files.

044048=MetaData of type "{0}" for class "{1}" not found
044049=MetaData of type "{0}" for class "{1}" NOT found at {2}
044050=MetaData for query {0} NOT found at {1}
044051=MetaData for sequence {0} NOT found at {1}
044052=MetaData of type "{0}" for class "{1}" will use {2}
044053=MetaData for query {0} will use {1}
044054=MetaData for sequence {0} will use {1}
044055=Failure to parse MetaData file {0}
044056=File "{0}" is having internal MetaData definition updated with ORM information
044057=The package name in empty in MetaData file {0}.

044058=The package {0} has an empty MetaData specified for a class name. Please check the file {1}.

044059=Found Meta-Data for class {0} but this class is either not enhanced or you have multiple copies of jdo-api.jar in your CLASSPATH!! Make sure all persistable classes are enhanced before running DataNucleus and/or the CLASSPATH is correct.
044060=Class "{0}" field "{1}" : Adding Meta-Data for field since it didn't appear in the Meta-Data definition.
044061="class" Meta-Data element for package {0} needs a 'name' attribute.

044063=Class "{0}" has been specified to be persistable yet is an inner class and is not static. Non-static inner classes cannot be persistable.

044064=Class "{0}" is defined as having \"superclass-table\" inheritance and there is no known superclass with its own table. Duhhhhhhh

044065=Class {0} has application-identity and no objectid-class specified yet has {1} primary key fields. Unable to use SingleFieldIdentity.
044066=Class {0} has application-identity, no objectid-class and 1 PK field, but the field is of an invalid type {1} for SingleFieldIdentity. You are allowed to use short, Short, int, Integer, long, Long, byte, Byte, char, Character, or String types.
044067=Class "{0}" : No class loader specified for loading of classes associated with MetaData for this class. Using the default ClassLoader.
044068=Class "{0}" : Cannot populate the class since it is already populated.
044069=Class "{0}" : Meta-Data hasnt been initialised for the class
044070=Class "{0}" : Meta-Data hasnt been populated for the class
044071=Class "{0}" field "{1}" : declared in MetaData, but this field doesn't exist in the class!
044072=Class "{0}" : has property {1} declared in MetaData, but this method doesn't exist in the class!
044073=Class "{0}" : has property {1} declared in MetaData, but its getter method doesn't exist in the class!
044074=Class "{0}" : has property {1} declared in MetaData, but its setter method doesn't exist in the class!
044075=Class "{0}" : Populating Meta-Data
044076=Class "{0}" : Initialising Meta-Data
044077=Class "{0}" has been specified with an object-id class {1} yet no fields have been identified as primary key fields. Please notate using the "primary-key" tag against the fields that should be considered part of the primary key.
044078=Class "{0}" has been specified with {1} primary key fields, but this class is using {2} identity and should be application identity.
044079=Class "{0}" has been specified with an object-id class {1}. This class cannot be found. Please check your specification and/or CLASSPATH.
044080=Class "{0}" has MetaData yet the class cant be found. Please check your CLASSPATH specifications.
044081=Class "{0}" has a persistence-capable-superclass {1} which is not found.
044082=Class "{0}" has a persistence-capable-superclass {1} which is NOT a superclass of the class.
044083=Class "{0}" has a persistence-capable-superclass {1} which is not Persistence-Capable (no Meta-Data found).
044084=Class "{0}" has the persistence-capable-superclass {1}, but there is no metadata existing for the superclass.
044085=Class "{0}" has the persistence-capable-superclass {1}, but defines a different objectid-class than its superclass. No objectid-class should be specified because the superclasses id is always used.
044086=Class "{0}" has the persistence-capable-superclass {1} however it has been specified with an objectid-class. No objectid-class should be specified because the superclasses id is always used.
044087=Class "{0}" : The persistence-capable-superclass must be class {1}, NOT class {2}.
044088=Class "{0}" : The persistence-capable-superclass {1} cant be found. Please check your CLASSPATH specifications.
044089=Class "{0}" has had its persistence-capable-superclass set to "{1}" - it wasnt specified in the MetaData.
044090=Class "{0}" already has a field with the name {1} defined.
044091=Class "{0}" has not been declared with a persistence-capable-superclass, yet it has a superclass "{1}" that IS persistence capable. Please correct this error.

044093=Class "{0}" : Identity Type is not the same as the Identity Type declared in super class.
044094=Class "{0}" : Datastore-identity strategy ("{1}") is not the same as the Datastore-Identity strategy declared in the super class(es) ("{2}").
044095=Class "{0}" is having internal MetaData definition updated with Annotations information
044096=Class "{0}" is having internal MetaData definition updated with ORM information
044097=Class "{0}" has MetaData with implements {1} yet the class cant be found. Please check your CLASSPATH specifications.
044098=Class "{0}" has been specified with an inheritance strategy of "{1}" yet only "{2}" is supported currently
044099=Class "{0}" has been specified with an inheritance strategy of "superclass-table", yet no superclass exists or none exists with its own table!
044100=Class "{0}" has been specified to use an inheritance strategy of "superclass-table", persisting to the table of class {1}, however this class doesn't have a discriminator specified.
044101=Class "{0}" has been specified to use an inheritance strategy of "superclass-table", persisting to the table of class {1}, however this class doesn't have a discriminator column specified.
044102=Class "{0}" has been specified to persist to table of class "{1}" using discriminator column {2}. No discriminator value has been specified for this class!
044103=Class "{0}" has a discriminator strategy of "value-map" but has no value. Will use the name of the class since nothing else is available!
044104=Class "{0}" has been specified with an inheritance strategy of "{1}" yet this is not currently supported by DataNucleus. Using default strategy instead
044105=Class "{0}" is abstract yet has been defined with a discriminator value. The value will never be used!

044106=Class "{0}" field "{1}" : Cannot populate the field with a null field.
044107=Class "{0}" field "{1}" : Cannot populate the field since it is already populated.
044108=Class "{0}" field "{1}" : Cannot update the field since it is already initialised.
044109=Class "{0}" field "{1}" : this is declared as {2} with "persistence-modifier={3}" yet has either "default-fetch-group=true" or "primary-key=true" specified! These should be false.
044110=Class "{0}" field "{1}" : this is declared with a "dependent" attribute, but it is a collection, array or map field for which dependency must be declared in an enclosed "array", "collection" or "map" tag, e.g. as "dependent-element" (for collections)   
044111=Class "{0}" field "{1}" : Cannot persist field since it is of an array type that is not supported by DataNucleus. Please consider making this a Collection field.
044112=Class "{0}" field "{0}" : has already been specified, yet has duplicate definition.
044113=Class "{0}" field "{1}" : specified to be from class "{2}" but this class could not be found!
044114=Class "{0}" field "{1}" : specified to be from class "{2}" but this class is not a superclass of the given class! You can only override fields in persistable superclasses
044115=Class "{0}" field "{1}" : has "mapped-by" specified as "{2}". This field doesnt exist in the target of the relation ("{3}")!!
044116=Class "{0}" field "{1}" : has "implementation-classes" specified yet the implementation class "{2}" is not found!!
044117=Class "{0}" field "{1}" : Cannot populate with a the value "{2}" for the property "{3}".

044118=Class "{0}" field "{1}" : marked as persistent yet is final so cannot be persisted

044119=Class "{0}" : A column without field has been specified without its "name". Any "unmapped" column must have a name.
044120=Class "{0}" : A column "{1}" without field has been specified without its "jdbc-type". Any "unmapped" column must have a jdbc-type so DataNucleus has a clue how to set its value.

044121=Class "{0}" field "{1}" is of type "{2}" yet has been specified as embedded. DataNucleus doesnt support embedding of this type. Your embedded type must be persistable.
044122=Class "{0}" field "{1}" is a collection with elements of type "{2}" yet has been specified as the element being embedded. Your embedded type must be persistable.
044123=Class "{0}" field "{1}" is a map with keys of type "{2}" yet has been specified as the key being embedded. Your embedded type must be persistable.
044124=Class "{0}" field "{1}" is a map with values of type "{2}" yet has been specified as the value being embedded. Your embedded type must be persistable.
044125=Class "{0}" field "{1}" : adding Meta-Data for field embedded in class "{2}" since it didn't appear in the <embedded> Meta-Data definition.

044126=Class "{0}" defines a discriminator column, yet so does a superclass! In the vast majority of cases this declaration will be ignored (unless you are having a discriminator column in multiple tables down an inheritance tree).

044129=Class "{0}" field "{1}" has been specified to embed an object of type "{2}", yet this type is an interface and has been specified with an embedded FIELD "{2}". This should be a PROPERTY.
044130=Class "{0}" field "{1}" has <join table="...">. The attribute "table" is not applicable within <join> when it is specified under <field>.
044131=Class "{0}" field "{1}" : has <collection> and the element-type has more than 1 value. DataNucleus supports a single value only. If you want to specify many implementations you should use "implementation-classes" DataNucleus extension.
044132=Class "{0}" field "{1}" has been defined with "collection" MetaData yet is not a Collection Field.
044133=Class "{0}" field "{1}" has been defined as a Collection but the element type has not been specified!
044134=Class "{0}" field "{1}" has been defined as a Collection with elements of type {2}. This element type is not found.
044135=Class "{0}" field "{1}" has been defined as a Collection with elements of type {2}. This type has been resolved to {3}

044137=Class "{0}" field "{1}" : has been specified with an order mapped-by yet the mapped-by field ("{2}.{3}") doesnt exist
044138=Class "{0}" field "{1}" : has been specified with an ordering with a field ("{2}.{3}") that doesnt exist
044139=Class "{0}" field "{1}" : has been specified with an ordering with an invalid direction ("{2}"). Should be either ASC or DESC
044140=Class "{0}" field "{1}" : has <array> and the element-type has more than 1 value. DataNucleus supports a single value only. If you want to specify many implementations you should use "implementation-classes" DataNucleus extension.
044141=Class "{0}" field "{1}" : has been defined with "array" MetaData yet is not an array field.
044142=Class "{0}" field "{1}" is an array of (non-serialised) elements of type "{2}" yet no <join> has been specified. You must have a join table to store an array of non-persistable elements, or serialise the array.
044143=Class "{0}" field "{1}" has <map> and the key-type has more than 1 value. DataNucleus supports a single value only. If you want to specify many implementations you should use "key-implementation-classes" DataNucleus extension.
044144=Class "{0}" field "{1}" has <map> and the value-type has more than 1 value. DataNucleus supports a single value only. If you want to specify many implementations you should use "value-implementation-classes" DataNucleus extension.
044145=Class "{0}" field "{1}" has been defined with "map" MetaData yet is not a Map Field.
044146=Class "{0}" field "{1}" has been defined as a Map but the key type is not specified!
044147=Class "{0}" field "{1}" has been defined as a Map with keys of type {2}. This key type is not found.
044148=Class "{0}" field "{1}" has been defined as a Map with keys of type {2}. This key type has been resolved to {3}.
044149=Class "{0}" field "{1}" has been defined as a Map but the value type is not specified!
044150=Class "{0}" field "{1}" has been defined as a Map with values of type {2}. This value type is not found.
044151=Class "{0}" field "{1}" has been defined as a Map with values of type {2}. This value type has been resolved to {3}.
044152=Class "{0}" field "{1}" has been specified with a key-type of "{2}" which is a reference type, and that it should be embedded into a join table. DataNucleus doesnt support embedding of reference types into join tables.
044153=Class "{0}" field "{1}" has been specified with a value-type of "{2}" which is a reference type, and that it should be embedded into a join table. DataNucleus doesnt support embedding of reference types into join tables.
044154=Class "{0}" : Query for has been specified without a name !
044155=Class "{0}" : Sequence has been specified without a name !
044156=The strategy was not specified !
044157=The strategy was not specified !
044158=The factory-class {0} was not found !
044159=The factory-class {0} does not implement javax.jdo.IdGenerator !
044160=Invalid specification of <extension> tag. The vendor-name ({0}), key ({1}) and value ({2}) must ALL be specified.
044161=Class "{0}" field "{0}" : declared as a reference type (interface/Object) but no implementation classes of "{2}" have been found!
044162=Class "{0}" field "{1}" : declared in metadata, yet there is no such persistent capable superclass with this field

044200=Class "{0}" has been specified with {1} annotations so using those.
044201=Class "{0}" has an annotation "{1}" specified with property "{2}" yet this is invalid. Please check the specification for that annotation class.
044202=Class "{0}" has annotations but there is no registered AnnotationReader. Please check your CLASSPATH and the annotations in the class for validity.
044203=Class "{0}" has an annotation "{1}" which was not processed here (will be processed separately if a DataNucleus extension annotation).
044204=Class "{0}" : @Index specified but had no field/column specification and so is ignored
044205=Class "{0}" : @Unique specified but had no field/column specification and so is ignored
044206=Class "{0}" : @ForeignKey specified but had no field/column specification and so is ignored
044207=Class "{0}" has specifications of @FetchPlan AND @FetchPlans. You should have only one
044208=Class "{0}" has specifications of @FetchGroup AND @FetchGroups. You should have only one
044209=Class "{0}" has specifications of @Query AND @Queries. You should have only one
044210=Class "{0}" has specifications of @Join AND @Joins. You should have only one
044211=Class "{0}" field "{1}" has an annotation "{2}" which was not processed here (will be processed separately if a DataNucleus extension annotation).

#
# Datastore Connection
#
046000=Not valid to call method "{0}" on a data store connection obtained from the PersistenceManager.
046001=Connection is no longer available

#
# Query Result
#
052600=Query result has been closed
052601=Failed to read the result set : {0}
052602=No more elements in query result
052603=Query result sets are not modifiable
052604=This operation is not supported on Query Results
052605=Closing query result failed : {0}
052606=Reading in results for query "{0}" since the connection used is closing

#
#
#
055009=Object "{0}" has field "{1}" with a 1-N bidirectional relation and adding element "{2}" so setting the owner of the element.
055010=Object "{0}" has a 1-N bidirectional collection field "{1}" and having element removed. Element "{2}" is having its owner field nulled.

#
# SCO
#
056000=The field "{0}" has been declared as being an array, yet there is no <array> MetaData specified!
056001=The field "{0}" has been declared as being a collection, yet there is no <collection> MetaData specified!
056002=The field "{0}" has been declared as being a map, yet there is no <map> MetaData specified!
056003=The MetaData for the element class "{0}" of the collection field "{1}" was not found.
056004=The MetaData for the value class "{0}" of the map field "{1}" was not found.
056005=Iterator query statement is null !!
056006=Iteration request failed : {0}
056007=Size request failed : {0}
056008=Contains request failed : {0}
056009=Add request failed : {0}
056010=Update embedded key failed : {0}
056011=Update embedded value failed : {0}
056012=Remove request failed : {0}
056013=Clear request failed : {0}
056014=Get request failed : {0}
056015=Set request failed : {0}
056016=Put request failed : {0}
056017=IndexOf request failed : {0}
056018=ContainsKey request failed : {0}
056019=ContainsValue request failed : {0}
056020=MaxAdapterColumnId request failed : {0}
056021=Can't query over a Collection of second-class elements.
056022=Can't query over a Map of second-class elements.
056023=GetIndices failed : One or more elements specified doesnt exist : {0}

056024=Field "{0}" has been defined as "mapped-by" the field "{1}" yet this "mapped-by" field doesn't exist in the class "{2}".
056025=Field "{0}" has been defined as "mapped-by" field "{1}" yet this is of an incorrect type ({2}). The field that is set as the "mapped-by" must be of type "{3}"
056026=The owner field {0} of element class {1} has an incorrect type "{2}". Should be "{3}"
056027=Could not update the foreign key using statement : {0}
#
# SCO Collection
#
056028=Collection field "{0}" has been specified to contain the element "{1}" unembedded yet this is already identified as being stored embedded in a different field. This is invalid. You can't store the same object embedded and unembedded!

056029=Class "{0}" has collection field "{1}" and this has no mapping in the table for the element class "{2}" owner field "{3}"
056030=Class "{0}" has collection field "{1}" and this has no mapping in the table for the element class "{2}"

056031=The field "{0}" is a collection field where the elements use "subclass-table" inheritance strategy and where there are more than 1 subclass where the element is persisted. DataNucleus doesnt currently support this situation.
056032=Collection has been defined with elements of an interface type "{0}" and there are more than 1 implementation for this interface type found. DataNucleus doesnt currently support use of interface where there is more than 1 interface implementation.

056033=Class {0} is not a valid element type for this collection (Field "{1}"). Must be "{2}" or subclass

056034=Removal of element(s) from FK Collection deletes the element(s) since the field is "dependent"
056035=Removal of element(s) from FK Collection deletes the element(s) since owner/index columns weren't nullable
056036=Removal of element(s) from FK Collection nulls the FK while leaving the element(s) intact.

056037=Object "{0}" has a collection "{1}" yet element "{2}" doesnt have the owner set. Managing the relation and setting the owner.
056038=Object "{0}" has a collection "{1}" yet element "{2}" has its owner set to "{3}". This is inconsistent and needs correcting.

#
# SCO Set
#
056039=Null elements not allowed in persistent sets.
056040=Collection field "{0}" was asked to add element "{1}" to the M-N relation but the element already has this field in its collection

#
# SCO List
#
056041=Class "{0}" has collection field "{1}" and this has no mapping in the table for the index of the element class "{2}". Maybe you declared the field as a java.util.Collection and instantiated it as a java.util.List yet omitted the <order> element in the MetaData ?
056042=Remove of element from Inverse List deleted the element since owner/index columns weren't nullable
056043=Remove of element from Inverse List removed the element from the List while leaving the element intact.
056044=Field "{0}" has been instantiated as a List using a join table yet the join table has no "ordering" column. Please specify the <order> tag in the MetaData.

#
# SCO Array
#
056045=The field "{0}" is an array field where the elements use "subclass-table" inheritance strategy and where there are more than 1 subclass where the element is persisted. DataNucleus doesnt currently support this situation.
056046=Class "{0}" has array field "{1}" and this has no mapping in the table for the element class "{2}" owner field "{3}"
056047=Class "{0}" has array field "{1}" and this has no mapping in the table for the element class "{2}"
056048=Class "{0}" has array field "{1}" and this has no mapping in the table for the index of the element class "{2}"
056049=Array is of an interface type "{0}" and there are more than 1 implementation for this interface type found. DataNucleus doesnt currently support use of interface where there is more than 1 interface implementation.

#
# SCO Map
#
056050=The Map "{0}" has been specified without a key "mapped-by" field. You must specify a <key mapped-by=...> since the key is a field in the value class.
056051=The Map "{0}" has been specified with a key type of "{1}" yet the field of the key in the value class is of type "{2}"!
056052=Value class "{0}" has been defined to contain a field "{1}" that represents the key of the map but this field was not found!

056053=Class "{0}" has map field "{1}" and this has no mapping in the table for the value class "{2}" key field "{3}"
056054=Class "{0}" has map field "{1}" and this has no mapping in the table for the key class "{2}" value field "{3}"
056055=The owner field {0} of value class {1} has an incorrect type "{2}". Should be "{3}"
056056=Class "{0}" has map field "{1}" and this has no mapping in the table for the value class "{2}"

056057=The Map "{0}" has been specified without a value "mapped-by" field. You must specify a <value mapped-by=...> since the value is a field in the key class.
056058=The Map "{0}" has been specified with a value type of "{1}" yet the field of the value in the key class is of type "{2}"!
056059=Key class "{0}" has been defined to contain a field "{1}" that represents the value of the map but this field was not found!

056060=Can't write key from a different Persistence Manager
056061=Can't write value from a different Persistence Manager
056062=Null keys not allowed in persistent maps.
056063=Null values not allowed in persistent maps.
056064=Class {0} is not a valid key type for this Map. Must be {1}
056065=Class {0} is not a valid value type for this Map. Must be {1}
056066=Map at "{0}" has been specified with a value-type "{1}" which is an interface. DataNucleus doesnt currently fully support the use of value-types that are interfaces. Please change the value-type to be a class.
056067=Field "{0}" has been defined as "mapped-by" the field "{1}" yet this "mapped-by" field doesn't exist in the class "{2}".
056068=Field "{0}" has been defined as "mapped-by" field "{1}" yet this is of an incorrect type ({2}). The field that is set as the "mapped-by" must be of type "{3}"

056069=The MetaData for the key class "{0}" of the map field "{1}" was not found.
056070=The MetaData for the value class "{0}" of the map field "{1}" was not found.

056071=Field "{0}" is a Map formed by a ForeignKey. There is no key/value "mapped-by" specified. You must specify <key mapped-by="..."> if you want to use a Map ForeignKey relation.
056072=Field "{0}" is a Map formed by a ForeignKey where the key is stored in the value object, however the value object is not persistable (it is "{1}"). The value must be persistable to use this type of relation.
056073=Field "{0}" is a Map formed by a ForeignKey where the value is stored in the key object, however the key object is not persistable (it is "{1}"). The key must be persistable to use this type of relation.
056074=Field "{0}" is a Map formed by a ForeignKey where the value is stored in the key object, however the DataNucleus doesnt currently support this type of relation.

056075=The field "{0}" is a collection field defined with an element type of "{1}" There are no concrete types persistable here


057023=Class "{0}" has not got its own table and no subclass tables are found for this class. Creation of schema is impossible!

#
# SQL
#
059000=Deletion by query is not supported for SQL queries.
059001=You have specified an empty SQL query. This is invalid.
059002=You have specified an SQL statement ("{0}") that doesnt start with SELECT. This is invalid.
059004=Candidate extents not applicable to SQL queries.
059005=Candidate collections not applicable to SQL queries.
059006=Result is not applicable to SQL queries.
059007=Range is not applicable to SQL queries.
059008=Filter strings not applicable to SQL queries.
059009=Variables not applicable to SQL queries.
059010=SQL only supports grouping when set explicitly using a GROUP BY in the SQL text.
059011=SQL only supports ordering when set explicitly using an ORDER BY in the SQL text.
059012=SQL Query : "{0}"
059016=Parameters are untyped in SQL queries.
059025=Error executing SQL query "{0}".
059026=Imports not applicable to SQL queries.
059027=Error executing stored procedure query "{0}".
059028=SQL query "{0}" requires {1} parameters yet none have been supplied
059030=SQL query "{0}" requires a parameter with name "{1}" yet none was supplied in the input Map

#
# Enhancer
#
Enhancer.ClassEnhancer=DataNucleus Enhancer (version {0}) for API "{1}" using JRE "{2}"
Enhancer.Classpath=DataNucleus Enhancer : Classpath
Enhancer.Classpath.Entry=>>  {0}

Enhancer.InputFiles.Invalid=Input file "{0}" doesnt exist!
Enhancer.NoInputFilesError=No input (metadata/class) files specified!
Enhancer.NoValidInputFilesError=No valid input (metadata/class) files specified!
Enhancer.ErrorReadingInputFiles=An error was encountered reading the specified input files. Please consult the log for details. The following may help : {0}

Enhancer.Success=DataNucleus Enhancer completed with success for {0} classes. Timings : input={1} ms, enhance={2} ms, total={3} ms. Consult the log for full details
Enhancer.Success.Simple=DataNucleus Enhancer completed with success for {0} classes.
Enhancer.Failure=DataNucleus Enhancer completed with an error. Please review the enhancer log (at DEBUG level) for full details. Some classes may have been enhanced but some caused errors
Enhancer.NoClassesEnhanced=DataNucleus Enhancer completed and no classes were enhanced. Consult the log for full details

Enhancer.PersistenceUnit.NoPersistenceFiles=No "persistence.xml" files were found in the CLASSPATH yet you specified as input the name ("{0}") of a "persistence-unit" to enhance. You must have a valid "persistence.xml" file in the CLASSPATH in a valid location to use this option.
Enhancer.PersistenceUnit.NoSuchUnit=No "persistence-unit" of name "{0}" was found in the CLASSPATH. Please check the "persistence.xml" files available

Enhancer.ReadInputFilesStart=Reading {0} input files/classes ...
Enhancer.ReadInputFilesEnd=Completed read of {0} input files/classes

Enhancer.EnhanceClassStart=Enhance of class "{0}" starting ...
Enhancer.EnhanceClassEnd=Enhance of class "{0}" completed

Enhancer.ValidateClassStart=Validation of enhancement of class "{0}" starting ...
Enhancer.ValidateClassEnd=Validation of enhancement of class "{0}" completed

Enhancer.SetupClass=Setting up class "{0}" for enhancement
Enhancer.ClassIsAlreadyEnhanced=Class "{0}" is already enhanced.
Enhancer.ClassHasNoSuchField=Class "{0}" has no such field "{1}"
Enhancer.ClassHasNoSuchMethod=Class "{0}" has no such method "{1}"
Enhancer.WriteClass=Writing class file "{0}" with enhanced definition
Enhancer.GeneratePrimaryKey=Class "{0}" needs a primary-key class generating, of name {1}
Enhancer.WritePrimaryKeyClass=Writing primary-key class file "{0}"
Enhancer.ClassNotFound=Class {0} not found in classpath. : {1} 
Enhancer.ErrorEnhancingClass=An error was encountered whilst enhancing class "{0}" : {1}
Enhancer.ProcessingClass=Processing class "{0}"
Enhancer.FieldNotFound=Field {0} was specified in the MetaData but is not found in that class!

Enhancer.AddMethod=Adding method "{0}"
Enhancer.AddConstructor=Adding constructor "{0}"
Enhancer.AddField=Adding field "{0}"
Enhancer.AddInterface=Adding interface: {0}
Enhancer.EnhanceOriginalMethodField=Enhancing original method {0} changing field "{1}" for call to "{2}"
Enhancer.EnhanceOriginalMethod=Enhancing original method {0}->{1}
Enhancer.EnhanceOriginalMethodFieldOmit=Enhancing original method {0} : omitting enhance of {1} of field "{2}"
Enhancer.RequiresDefaultConstructor=Class {0} doesn't have a default constructor. All persisted classes need a default constructor
Enhancer.PersistentInnerClassMustBeStatic=Class {0} is a persistent inner class but is NOT static. If the persistent class is an inner class it MUST be static.
Enhancer.FieldIsNull=Class {0} has a null field {2} in method {1}. It means that the enhancer could not find the field. 

Enhancer.DetachedFieldAccess=You have just attempted to access field "{0}" yet this field was not detached when you detached the object. Either dont access this field, or detach it when detaching the object.
Enhancer.DetachedPropertyAccess=You have just attempted to access property "{0}" yet this property was not detached when you detached the object. Either dont access this property, or detach it when detaching the object.

Enhancer.FieldConfigIsNullError=fieldConfig is null for field "{0}"
Enhancer.CallbackIsNullError=Callback is null
Enhancer.CallbackIsNotMethodBuilderError=Instance is not CreateMethodCallback class : {0}

Enhancer.Check.InterfaceMissing=Class "{0}" doesnt implement the interface "{1}" but is required
Enhancer.Check.FieldMissing=Class "{0}" doesnt have field "{1}" but is required
Enhancer.Check.FieldIncorrectAccess=Class "{0}" has field "{1}" but has incorrect access!
Enhancer.Check.FieldIncorrectType=Class "{0}" has field "{1}" but has incorrect type "{2}" (should be "{3}")
Enhancer.Check.MethodMissing=Class "{0}" doesnt have method "{1}" but is required
Enhancer.Check.MethodIncorrectAccess=Class "{0}" has method "{1}" but has incorrect access!

#
# ImplementationCreator
#
ImplementationCreator.InstanceCreateFailed=Attempt to create an instance of "{0} " failed!
ImplementationCreator.DifferentClassLoader=Instance implements persistable loaded by "{0}" but target persistable has classloader "{1}".
ImplementationCreator.NotPCProblem=A new instance of "{0}" was created, but it is not assignable to PersistenceCapble. Perhaps a classloading problem. "{1}" The instance implements "{2}"
ImplementationCreator.AbstractClassMethodUndefined=Abstract class "{0}" has abstract method "{1}" but this is not defined as a persistent property in MetaData
ImplementationCreator.InterfaceMethodUndefined=Interface "{0}" has method "{1}" but this is not defined as a persistent property in MetaData
