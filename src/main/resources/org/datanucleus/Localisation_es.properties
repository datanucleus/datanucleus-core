################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contributors:
#     ...
#
# Resources for org.datanucleus package (Spanish)
################################################################################
#
# ClassLoader
#
001000=¡La clase {0} no esta en el CLASSPATH!. Por favor compruebe la especificación y el CLASSPATH.
001001=PersistenceManagerFactory tiene ClassLoaderResolver de nombre "{0}" pero el mecanismo de plugin de DataNucleus no lo ha encontrado. Por favor compruebe el CLASSPATH y especificación de plugin.
001002=ClassLoaderResolver plugin con clase "{0}" pero no existe! Por favor compruebe el CLASSPATH y especificación de plugin.
001003=ClassLoaderResolver para la clase "{0}" ha dado error en la creación : {1}
001004=¡La clase {0} no esta en el CLASSPATH! [ClassResolver llamado por {1} (linea {2})]
001005=¡La clase {0} no esta en el CLASSPATH!.
001006=¡La clase "{0}" no esta en el CLASSPATH!. Usted tiene que tener "{1}" en el CLASSPATH!

#
# DatastoreIdentity
#
002001=PersistenceManagerFactory tiene datastore-identity de nombre "{0}" pero el mecanismo de plugin de DataNucleus no lo ha encontrado. Por favor compruebe el CLASSPATH y especificación de plugin.
002002=datastore-identity "{0}" usa clase "{1}" pero la clase no existe! Por favor compruebe el CLASSPATH y especificación de plugin.
#
# L1 Cache
#
003001=Cache de nivel 1 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
003002=Cache de nivel 1 "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
003003=Cache de nivel 1 del tipo "{0}" inicializada
003004=Objeto "{0}" (id="{1}") añadido a la Cache de nivel 1 (loadedFlags="{2}")
003005=Objeto "{0}" (id="{1}") cambiado en la Cache de nivel 1 (loadedFlags="{2}")
003006=Intenta añadir a la Cache de nivel 1 un objeto con id nulo. Rechazado.
003007=Objeto con id "{0}" no esta en la Cache de nivel 1 [tamaño = {1}]
003008=Objeto "{0}" (id="{1}") usado de la Cache nivel 1 (loadedFlags="{2}") [tamaño = {3}]
003009=Objeto con id="{0}" va a ser borrado de la Cache de nivel 1 [tamaño ahora = {1}]
003010=Object con id="{0}" no podia ser borrado de la Cache de nivel 1 - no existia
003011=Cache de nivel 1 vaciada.
003012=Objeto "{0}" (id="{1}") va a ser cambiado para ser referenciado por id="{2}" en la Cache de nivel 1
#
# L2 Cache
#
004000=Cache de nivel 2 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
004001=Cache de nivel 2 "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
004002=Cache de nivel 2 del tipo "{0}" inicializada
004003=Objeto "{0}" (id="{1}") añadido a la Cache de nivel 2 (campos="{2}", version="{3}")
004004=Intenta añadir a la Cache de nivel 2 un objeto con id nulo. Rechazado.
004005=Objeto con id "{0}" no esta en la Cache de nivel 2
004006=Objeto con identidad="{0}" usado de la Cache nivel 2 (campos="{1}", version="{2}") - representado como "{3}"
004007=Objeto "{0}" (id="{1}") borrado de la Cache de nivel 2
004008=Objeto "{0}" (id="{1}") no podia ser borrado de la Cache de nivel 2 - no existia
004009=Cache de nivel 2 vaciada.
004010=Objeto "{0}" (id="{1}") va a ser cambiado para ser referenciado por id="{2}" en la Cache de nivel 2
004011=Intenta almacenar un valor nulo en la Cache. No es posible.
004012=No se puede añadir el objeto "{0}" a la Cache de nivel 2 porque esta conectado a un PersistenceManager.
004014=Objeto con identidad="{0}") borrado de la Cache de nivel 2 porque ha cambiado pero ha sido GCed
004015=Objeto "{0}" (id="{0}") cambiado en la Cache de nivel 2 (campos="{2}", version="{3}") para campos "{4}"
004016=Objeto con identidad="{0}" borrado de la Cache de nivel 2

#
# Enhancer
#
005000=DataNucleus Enhancer (versión {0}) para el API "{1}" utilisando el JRE "{2}"
005001=DataNucleus Enhancer : Classpath
005002=>>  {0}
005003=¡Archivo "{0}" no existe!
005004=DataNucleus Enhancer ha terminado con exito para {0} clases. Tiempos : input={1} ms, enhance={2} ms, total={3} ms. Compruebe el LOG para los detalles
005005=DataNucleus Enhancer ha terminado con exito para {0} clases.
005006=DataNucleus Enhancer ha terminado con un error. Por favor lee el LOG para los detalles. Habia errores con algunas de las clases
005007=DataNucleus Enhancer ha terminado sin enhance ninguna clase. Compruebe el LOG para los detalles.

005008=Ningun archivo "persistence.xml" ha sido encontrado en el CLASSPATH pero entro el nombre ("{0}") de un "persistence-unit". Tiene que tener el archivo "persistence.xml" en el CLASSPATH en una carpeta valida para esta opción.
005009=Ningun "persistence-unit" con nombre "{0}" existe en el CLASSPATH. Por favor compruebe los archivos "persistence.xml" disponible

005010=Enhance de la clase "{0}" empezando ...
005011=Enhance de la clase "{0}" ha terminado

005012=Validacion de enhancement de la clase "{0}" empezando ...
005013=Validacion de enhancement de la clase "{0}" ha terminado

005014=La clase "{0}" esta enhanced.

005015=Escribiendo el archivo de clase "{0}" con definicion enhanced
005016=La clase "{0}" necesita clase de primary-key; creandola con nombre {1}
005017=Escribiendo el archivo de clase de primary-key "{0}"
005018=Hemos encontrado un error durante el enhance de la clase "{0}" : {1}

005019=Agregando el metodo "{0}"
005020=Agregando el constructor "{0}"
005021=Agregando el campo "{0}"
005022=Agregando el interfaz: {0}

005023=Enhancing metodo original {0}, cambiando el uso del campo "{1}" para utilisar "{2}"
005024=Enhancing metodo original {0} : ignorando enhance de {1} del campo "{2}"

005025=Has intentado utilisar el campo "{0}" pero el campo no estaba detachado cuando detacha el objeto. No debes utilisar el campo, o debes detacharlo mientras detacha el objeto.
005026=Has intentado utilisar la propiedad "{0}" pero la propiedad no estaba detachado cuando detacha el objeto. No debes utilisar la popiedad, o debes detacharlo mientras detacha el objeto.

005027=La clase "{0}" no implementa el interfaz "{1}"!
005028=La clase "{0}" no tiene el campo "{1}" pero lo necesita
005029=La clase "{0}" tiene el campo "{1}" pero el acceso esta incorecta
005030=La clase "{0}" tiene el campo "{1}" pero tiene tipo incorecta "{2}" (debe ser "{3}")
005031=La clase "{0}" no tiene el metodo "{1}" pero lo necesita
005032=La clase "{0}" tiene el metodo "{1}" pero el acceso esta incorecta

#
# FetchPlan
#
006000=El campo "{0}" del fetch-group "{1}" no existe en la clase "{2}
006001=Fetch-group "{0}" jerarquizado en el fetch-group "{1}" no existe en la clase "{2}"
006002=El valor {0} no tiene ningun sentido para maxFetchDepth. Usted tiene que poner -1 (no hay limite) o un valor positivo.
006003=No se puede cambiar los raices de detachar antes de commit().
006004=Intenta añadir el campo "{0}" al fetch group de la clase "{1}", pero el campo no existe en la clase!

#
# Reachability
#
007000=Object "{0}" (id="{1}") estado de vida "{2}" añadido a la lista de alcanzables al commit.
007002=Haciendo la calculación de alcanzables con el contenedor de SCO al campo "{0}"
007003=Haciendo la calculación de alcanzables en el campo de array "{0}"
007004=Haciendo la calculación de alcanzables en el campo de PC "{0}"
007005=No podremos encontrar el StateManager del objeto de PC "{0}" al campo "{1}" - ignorandolo
007006=El campo "{0}" ha sido seleccionado no usar "cascade-persist". No vamos a persistir este campo.
007007=El campo "{0}" va a ser persistido por "cascade-persist".
007008=El campo "{0}" ha sido seleccionado no usar "cascade-update". No vamos a persistir este campo.
007009=El campo "{0}" va a ser cambiado por "cascade-update".

#
# NucleusContext
#
008000=DataNucleus Context : Versión: "{0}" con JRE "{1}" en "{2}"
008003=No hay ningun adaptador de API "{0}". Usando lo que tenemos ahora mismo
008004=No hay ningun StoreManager del tipo "{0}". Por favor compruebe que usted ha puesto "datanucleus.storeManagerType" correctamente y que todos los plugins necesarios estan en el CLASSPATH
008005=No hay ningun StoreManager para la clave de URL de base de datos "{0}". Por favor compruebe que los plugins existen en el CLASSPATH (datanucleus-rdbms?, datanucleus-db4o?), y piensa de poner la propiedad de persistencia "datanucleus.storeManagerType" al tipo de base de datos que quiere e.g rdbms, db4o

008009=El MetaDataManager para el API "{0}" no esta registrado. Por favor compruebe que el plugin apropiado esta en el CLASSPATH
008010=Error en la creción del MetaDataManager para el API "{0}" : {1}
008011=La propiedad {0} ha sido especificada pero no podemos usarla porque la base de datos es de sólo-lectura
008012=La propiedad "{0}" tiene el valor "{1}" pero el valor no es válido. Por favor consulte la documentacion para ver la lista de valores correctos.
008013=El archivo de propiedades "{0}" leemos antes. Vamos a ignorar el archivo de propiedades "{1}"
008014=No se puede leer el archivo de propiedades "{0}"
008015=Propiedad {0} desconocida - vamos a ignorarla
008016=GenerateSchema : no era posible generar el esquema como este base de datos ("{0}") no soporta operaciones del esquema
008017=Compiling NamedQuery {0} : "{1}"

#
# Connections
#
009000=La Connección ha sido reservado por usted y debe cerrarla antes de usar operaciones del API.
009001=La factoría de conexiones ({0}) no está soportada - debe ser un javax.sql.DataSource
009002=La factoría de connecciones "{0}" no existe o no se encuentra disponible
009003=Ya existe una conexión a la base de datos - quizas un Query siga ? La especificacion de JDO sección 12.6 dice que un PersistenceManager puede usar solamente una connección a la base de datos en un momento. Si usted quiere hacer otras operaciones, debe usar más PersistenceManagers.
009004=ManagedConneccion encontrado en el pool : "{0}" para clave="{1}" y fabrica="{2}"
009005=ManagedConneccion encontrado en el pool : "{0}" para clave="{1}" y fabrica="{2}" pero el dueño esta caerrando asi que cerramos la connección
009006=ManagedConneccion borrado del pool : "{0}" para clave="{1}" y fabrica="{2}"
009007=ManagedConneccion agregado al pool : "{0}" para clave="{1}" y fabrica="{2}"
009008=Algunas opciones de la conexión ({0}) serán sobreescritas por las de la transacción ({1})"

009010=Error en abrir una connección para datasource "{0}" - compruebe la especificación de datasource y/o driver
009011=ManagedConnection(non-enlisted) "{0}" abierto
009012=ManagedConnection(non-enlisted) "{0}" abierto con isolación "{1}" y auto-commit={2}
009013=ManagedConnection(non-enlisted) "{0}" cerrado
009014=ManagedConnection(non-enlisted) "{0}" ya esta cerrado!
009015=ManagedConnection(non-enlisted) "{0}" va a cometer
009016=ManagedConnection(non-enlisted) "{0}" va a rollback
009017=ManagedConnection(enlisted) "{0}" empezando para la transacción "{1}" con flags "{2}"
009018=ManagedConnection(enlisted) "{0}" esta preparando para la transacción "{1}"
009019=ManagedConnection(enlisted) "{0}" va a cometer para la transacción "{1}" con onePhase="{2}"
009020=ManagedConnection(enlisted) "{0}" fallo a cometer la connección para la transacción "{1}" con onePhase="{2}"
009021=ManagedConnection(enlisted) "{0}" va a rollback para la transacción "{1}"
009022=ManagedConnection(enlisted) "{0}" fallo a rollback la connección para la transacción "{1}"
009023=ManagedConnection(enlisted) "{0}" terminando para la transacción "{1}" con flags "{2}"

#
# ExecutionContext
#
010000=ExecutionContext "{0}" se abrió para la base de datos "{1}" con transaccion="{2}"
010001=ExecutionContext "{0}" se cerró
010002=ExecutionContext ya esta cerrado
010003=ExecutionContext.internalFlush() empezado con flush ordenado - {0} objetos registrados
010004=ExecutionContext.internalFlush() terminado
010005=Intento de obtener un objeto nondurable en estado HOLLOW por getObjectById!
010006=No hay ningun objeto nondurable con este identidad en el cache - ¿quizas de otro Manager?
010007=Objeto con id "{0}" es manejado por otro ExecutionContext
010008=Objeto no es detachado. Esta operación le hace falta un objeto en este estado
010009=Haciendo el objeto detachado : "{0}" (profundidad={1})
010010=Detachando una copia del objeto "{0}" (profundidad={1}) como "{2}" - campos-detachados={3}, campos-para-obtener={4}
010011=DetachOnClose : Cerrando Manager asi que haciendo detach con todos los objetos corrientes ...
010012=DetachOnClose : detach terminado
010013=No es posible detachar el objeto "{0}" (id="{1}") al cometer como ya no existe en la base de datos. Quizas haya una clave ajena que lo ha borrado
010014=No se puede usar detachCopy() fuera de una transacción cuando haya instancias en el estado "transient" alcanzable
010015=Haciendo el objeto persistente : "{0}"
010016=Haciendo el objeto persistente (adjuntar) : "{0}"
010017=Intento de adjuntar "{0}" a persistencia pero otro objeto persistente con la misma identidad ya existe para esta transaccion!
010018=Haciendo el objeto persistente (adjuntar) : "{0}" - adjuntando para ser "{1}"
010019=Borrando el objeto de persistencia : "{0}"
010020=No fué posible borrar objetos transitorios.
010021=No fué posible borrar objetos transitorios transaccional. Identidad de objeto = {0}
010022=Haciendo el objeto transitorio : "{0}"

010024=No fué posible cambiar el estado de objetos entre sucio transitorio y non-transaccional
010025=No fué posible cambiar el estado de objetos entre transitorio y non-transaccional
010026=Objeto no existe
010027=El objeto con id "{0}" no ha sido encontrado
010028=No fué posible crear una identidad de objeto por una clase que es nulo!
010029=No fué posible crear una identidad de objeto por la clase "{0}" porque el tipo de clave no esta soportada ({1})
010030=Ocurrió un error durante la construcción de una instancia de Id de tipo "{0}" por la clase abstracta "{1}"
010031=Algunos objetos han fallado de commit() debido a problemas de verificación optimista.
010032=Haciendo la comprobación de "persistence-by-reachability" (commit) ...
010033=El objeto con identidad "{0}" se almacenó con una llamada a makePersistent() pero ya no esta accesible. Vamos a borrar el objeto de la base de datos.
010034=Ha terminado la comprobación de "persistence-by-reachability" (commit).
010035=Cannot perform operation since ImplementationCreator doesnt exist in the CLASSPATH (put datanucleus-enhancer.jar in the CLASSPATH).
010036=No fué posible desahuciar algunos de los objetos
010037=No fué posible refrescar algunos de los objetos
010038=No fué posible recuperar algunos de los objetos
010039=No fué posible hacer persistente algunos de los objetos
010040=No fué posible borrar algunos de los objetos
010041=No fué posible hacer transitorio algunos de los objetos
010042=No fué posible hacer transaccional algunos de los objetos
010043=No fué posible hacer non-transaccional algunos de los objetos
010044=No fué posible encontrar el objeto con identidad nulo!!
010045=No fué posible encontrar el objeto con identidad "{0}" del tipo "{1}" como es abstrato y usted no quisó la validación
010046=ExecutionContext.internalFlush() empezado con flush optimizado - {0} para borrar, {1} para persistir, {2} para cambiar
010047=Objeto "{0}" ha sido detachado antes de flush sus cambios a la base de datos. Los cambios no van a llegar a la base de datos. Tiene que ser el resultado de un JPA detach() antes que flush(), que es una tonteria, pero lo hiciste señor!

010050=Intento de empezar una transaccion optimistica pero StoreManager para este base de datos no soporte optimistic locking! Elige "datanucleus.Optimistic" como falso.
010051=Intento de persistir un objeto con datastore-identity pero StoreManager para este base de datos no soporte ese identity type
010052=Intento de persistir un objeto con application-identity pero StoreManager para este base de datos no soporte ese identity type

#
# ImplementationCreator
#
011000=Instance implements persistable loaded by "{0}" but target persistable has classloader "{1}".
011001=A new instance of "{0}" was created, but it is not assignable to PersistenceCapble. Perhaps a classloading problem. "{1}" The instance implements "{2}"
011002=Abstract class "{0}" has abstract method "{1}" but this is not defined as a persistent property in MetaData
011003=Interfaz "{0}" tiene metodo "{1}" pero no existe como propiedad persistente en el MetaData

#
# Managed Relationships
#
013000=Manejar de relaciones : empezando
013001=Manejar de relaciones : terminado
013002=Manejar de relaciones : El objeto "{0}" tiene campo "{1}" cambiado a "{2}" pero el campo "{3}" de ese objeto ha sido cambiado a "{4}". Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013003=Manejar de relaciones : El objeto "{0}" tiene campo "{1}" cambiado a "{2}" pero el campo "{3}" de ese objeto ha sido cambiado a nulo. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013004=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" que ya tiene valor de "{2}" pero ya ese objeto va a relacionar con "{3}" asi que ponemos nulo en el campo
013005=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido cambiado para relacionar con este objeto, asi que cambiando nuestra relacion para estar de acuerdo
013006=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" con el campo "{2}" del objeto "{3}" pero ya no estan relacionados. Quitandolo del contenedor
013007=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" con el campo "{2}" del objeto "{3}" y debe estar en el contenedor pero no esta. Añadiendolo
013008=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido añadido, pero ese objeto ya este en estado borrado!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013009=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido añadido, pero tiene su dueño como "{3}"!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013010=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido borrado, pero tiene este objeto como su dueño!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"

#
# SchemaTool
#
014000=DataNucleus SchemaTool : Creación del esquema para clases
014001=DataNucleus SchemaTool : Eliminación del esquema para clases
014002=DataNucleus SchemaTool : Validación del esquema para clases
014003=DataNucleus SchemaTool : Información de la base de datos
014004=DataNucleus SchemaTool : Información del esquema
014005=DataNucleus SchemaTool : Classpath
014006=>>  {0}
014007=No hay input valido (unos ficheros de metadata/class, o el nombre de un "persistence-unit")!
014008=La creación de un PersistenceManagerFactory ha tirado una excepción : {0} - por favor, consulta el log para obtener mas informacion
014009=DataNucleus SchemaTool : Ficheros
014010=>>  {0}
014011=Leyendo {0} ficheros (metadata/class) ...
014012=Hemos acabado de leer {0} ficheros (metadata/class)
014013=Hemos encontrado un error procesando la clase ("{0}"), converiendola a un URL. Por favor, compruebe la especificación y el CLASSPATH
014014=Habia un error leyendo los ficheros. Por favor lee el LOG para obtener mas información. Lo siguiente puede ayudar : {0}
014015=DataNucleus SchemaTool : Usando esquema de persistence-unit "{0}"
014016=No hay archivos "persistence.xml" en el CLASSPATH pero usted ha seleccionado el nombre ("{0}") de "persistence-unit" para SchemaTool. Tiene que ser un archivo "persistence.xml" en el CLASSPATH en una locación valida para usar la opcion.
014017=No hay ningun "persistence-unit" con nombre "{0}" en el CLASSPATH. Por favor compruebe los archivos "persistence.xml" disponible
014018=Enviando Schema DDL a "{0}" para todas las clases
014019=Enviando Schema DDL a "{0}" solo para clases que no tiene esquema
014020=DataNucleus SchemaTool : Propiedades para persistencia
014021=No hemos encontrado metadata!
014022=>>  {0}={1}

014023=DataNucleus SchemaTool : Ayuda\n>> org.datanucleus.SchemaTool [opciones] [archivos-mapping] [archivos-clase]\ndonde las opciones son\n{0}\n"archivos-mapping" deben estar presentes en el CLASSPATH\n"archivos-clase" deben estar presentes en el CLASSPATH

014024=-createSchema <schemaName> : crear el esquema (si lo soporta la base de datos)
014025=-deleteSchema <schemaName> : borrar el esquema (se lo soporta la base de datos)
014026=-create : Crea las tablas de datos por las clases de los archivos-JDO/clase
014027=-delete : Borra las tablas de datos por las clases de los archivos-JDO/clase
014028=-validate : Valida las tablas de datos por las clases de los archivos-JDO/clase
014029=-dbinfo : Mostrar la información de base de datos (Database version, supported options, jdbc types, etc)
014030=-schemainfo : Mostrar la información de esquema (DDL statements)
014031=-ddlFile <filename> : enviar todo el DDL SQL a un fichero en vez de executarlos en la base de datos
014032=-completeDdl : escribir el DDL en total en vez de solo las partes que falta (con ddlFile)
014033=-help : Escribir este mensaje

014034=DataNucleus SchemaTool : Creación del esquema {0}
014035=DataNucleus SchemaTool : Eliminación del esquema {0}

014036=DataNucleus SchemaTool : Parametro "mode" solo accepta valores de "create", "delete", "validate", "dbinfo", "schemainfo"
014037=SchemaTool ha lanzado una excepción. Por favor consulte el Log para ver más detalles: {0}
014038=Ocurrió un error al analizar los archivos-JDO !
014039=No hay clases !
014040=No se encuentra la clase {0}! Por favor, compruebe que la clase existe en el CLASSPATH.
014041=No se encuentra el driver de base de datos!
014042=Error : No hay archivos XML de metainformación JDO !
014043=SchemaTool ha terminado con exito
014044=-delete-create : Borra las tablas de datos por las clases de los archivos-JDO/clase y crealas otra vez
014045=DataNucleus SchemaTool : Eliminación y Creación del esquema

#
# Transactions
#
015000=Transacción empezada para el ExecutionContext {0} (optimistic={1})
015001=Haciendo commit de la transaacción para el ExecutionContext {0}
015002=Haciendo rollback de la transacción para el ExecutionContext {0}
015003=Transacción empezada para la connection {0}
015004=La ransacción no se pudo comenzar
015005=La ransacción no se pudo flush
015006=Haciendo commit de la transacción para la connexión {0}
015007=No se puedo hacer commit de la transacción
015008=Haciendo rollback de la transacción para la connexión {0}
015009=Transaccion ha fallado de restaurar

015012=Nivel de aislamiento no es válido : {0}
015013=La connexión {0} empezó para una transacción pesimista
015014=La connexión {0} terminó para una transacción pesimistac
015015=La connexión {0} empezó para una transacción optimista
015016=La connexión {0} terminó para una transacción optimista
015017=Objeto "{0}" (id="{1}") ha sido puesto en la cache transaccional
015018=Objeto "{0}" (id="{1}") puesto en la cache transaccional ya esta referenciado por id="{2}"
015019=Objeto "{0}" (id="{1}") fue ser borrado de la cache transactional
015020=Transacción es "rollback-only", asi que no se puede hacer commit en este estado.
015021=No se pudo obtener una connexión.
015022=Transacción committed en {0} ms
015023=Transacción rolled back en {0} ms
015024=El uso de transacciones de JTA necesita una datasource manejado como tiene dependencia al TransactionManager para cometer las connecciones.
015025=Ya hemos asynchronisado con la transacción de JTA, pero hemos recibido otro pedido hacerlo!
015026=Transacción de JTA pero hemos recibido un error buscando la transacción de JTA.
015027=Transacción de JTA esta marcado por rollback, quizas un timeout. Cualquier otra operación que necesita accesso a la base de datos va a fallar.
015028=Error intentando obtener el estado de la transacción de JTA!
015029=Transacción de JTA es necesario para synchronisar con el TransactionManager de JTA, pero no era posible encontrar el NamingService. Por favor compruebe su configuración
015030=Transacción de JTA es necesario para synchronisar con el TransactionManager de JTA, pero no era posible encontrarlo (solo apoyamos WebLogic y JBoss)
015031=Una transacción de la base de datos ha sido restaurada, pero se lanzaron las siguientes excepciones durante la transición del estado de los objetos de JDO
015032=La transacción ya está activo.
015033=La transacción ya está activo.
015034=La transacción está activo todavia. Debe cerrar las transacciones usando los métodos commit() o rollback().
015035=La transacción no está activo. Tiene que poner este en una transacción o usar su PersistenceManagerFactory con 'NontransactionalRead' y 'NontransactionalWrite' como 'true'
015036=Se está haciendo commit o rollback de la transacción. Esta operación no esta disponible en este momento.
015037=Una transacción de base de datos ha sido acometida, pero se lanzaron las siguientes excepciones durante la transición del estado de los objetos de JDO
015038=Operation {0} failed on resource: {1}, error code {2} and transaction: {3}
015039=Running {0} operation on resource: {1}, error code {2} and transaction: {3}
015040=La transacción no está activo. Tiene que poner este en una transacción.
015041=Imposible performar la operacion como se hace falta una transaccion activa o 'NontransactionalRead' puesto. Usted no tiene ninguna de los dos.
015042=Imposible performar la operacion como se hace falta una transaccion activa o 'NontransactionalWrite' puesto. Usted no tiene ninguna de los dos.
015043=Este base de datos no soporte el nivel de isolacion de transacciones "{0}"
015044=Exception flushing work in JTA transaction. Mark for rollback. Look at the nested exception for details
015045=Cannot mark transaction for rollback after exception in beforeCompletion. PersistenceManager/EntityManager might be in inconsistent state
015046=Exception during afterCompletion in JTA transaction. PersistenceManager/EntityManager might be in inconsistent state
015047=Received unexpected transaction status "{0}"
015048=Transaction.afterCompletion called on {0} but is already closed. This is likely because you're using a JavaEE container like JBoss that has closed the EntityManager before calling afterCompletion on the transaction of that EntityManager - go figure. Any statistics gathering is rendered incorrect as a result.

#
# Types
#
016001=Tipo de Java {0} como el tipo de Java {1}
016002=Excepcion tirada en la conversion de "{0}" a un objeto del tipo "{1}"
016003=Tipos de Java inicializando ...
016004=La clase de mapping "{0}" no existe o no es encuentra. Por favor, compruebe la especificación de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
016005=La clase de SCO "wrapper" "{0}" no existe o no es encuentra. Por favor, compruebe la especificación de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
016006=Soporte para tipos de Java listo : tipos soportados = {0}
016007=Inicializando TypeConverters ...
016008=TypeConverters listo

#
# Sequence
#
017000=No hemos encontrado la secuencia "{0}". Por favor compruebe que existe en un archivo de Meta-Data.
017001=No hemos encontrado el factory-class "{0}" por la secuencia "{1}". Está en el CLASSPATH ?
017002=Ocurrió un error durante la invocacion de metodo newInstance() en el factory-class "{0}" : {1}
017003=La secuencia "{0}" ya existe y usa el generador "{1}"
017004=La secuencia "{0}" no tiene valores asignados. Por favor llame primero a "allocate(int)" para asignar los valores.
017005=La secuencia "{0}" no genera valores numéricos. Por favor llame a "next()" para obtener el valor como un Objeto.
017006=Error durante el proceso obtener la conexión por la generación de valor : {0}
017007=Error durante el proceso cerrar la conexión por la generación de valor : {0}
#
# Exceptions
#
018000=La clase "{0}" no es s epuede hacer persistente. Esto significa que no esta analizada, o que la version analizada no esta en el CLASSPATH (o antes se encuentra una version que no esta analizada), o que el Meta-Data/Annotaciones de la clase no existe o no se encuentra disponible.
018001=No hemos encontrado el Meta-Data/annotaciones para la clase "{0}". Por favor compruebe que lo ha puesto en un archivo XML correcto y válido.
018002=La clase "{0}" no es s epuede hacer persistente. Esto significa que no esta analizada, o que la version analizada no esta en el CLASSPATH (o antes se encuentra una version que no esta analizada), o que el Meta-Data de la clase no existe o no se encuentra disponible.
018003=No hemos encontrado el Meta-Data para la clase "{0}". Por favor compruebe que lo ha puesto en un archivo XML para JDO correcto y válido.
018004=La clase "{0}" no es Detachable. Este significa que el MetaData de la clase no incluyo el atributo "detachable" como "true".
018005=Algunos de los objetos no son de clases que son Detachable. Este significa que el MetaData de las clases no incluyo el atributo "detachable" como "true". Las excepciones adjuntas tienen los detalles de los objetos.
018006=El objeto de tipo "{0}" esta detachado. ¡No se puede utilizar objetos detachados con esta operación!
018007=La clase persistente no tiene un Extent (definido en el Meta-Data) : {0}
018008=El campo "{0}" contiene un objeto que no esta persistente pero el campo no permite persistencia por cascada.
018009=El campo "{0}" no existe en {1} o no es persistente
018010=El campo #{0} no existe en {1} o no es persistente
019000=La clase {0} ha sido definido con el object-id class {1} que es "inner" pero no es estatica. El ObjectId class debe ser estatica si es "inner".
#
# Primary Key
#
019001=La clase "{0}" ha sido definido con el object-id class {1} que no es publico. El ObjectId class debe ser publico.
019002=La clase "{0}" ha sido definido con el object-id class {1} que no es Serializable. El ObjectId class debe ser Serializable.
019003=La clase "{0}" que utilisa la clase de identidad de JDO SingleFieldIdentity, pero hay mas que un campo con primary-key para la clase. Se puede elegir solo un campo como primary-key
019004=La clase "{0}" ha sido definido con el object-id class {1} que no tiene constructor defecto. Todos los objectId classes deben tener un constructor defecto.
019005=La clase "{0}" ha sido definido con el object-id class {1} que no tiene un constructor de String. Todos los objectId classes deben tener un constructor de String.
019006=La clase "{0}" ha sido definido con el object-id class {1} que no define el metodo toString(). Todos los objectId classes deben definir el metodo toString().
019007=La clase "{0}" ha sido definido con el object-id class {1} que no define el metodo hashCode(). Todos los objectId classes deben definir el metodo hashCode() para utilizar todos los campos de la clave primaria.
019008=La clase "{0}" ha sido definido con el object-id class {1} que no define el metodo equals(). Todos los objectId classes deben definir el metodo equals() para utilizar todos los campos de la clave primaria.
019009=La clase "{0}" ha sido definido con el object-id class {1} que tiene el campo {2} que no es Serializable. Todos los campos non-estaticos del objectId class deben ser Serializable.
019010=La clase "{0}" ha sido definido con el object-id class {1} que tiene un campo {2} que no es publico. Todos los campos non-estaticos de un objectId class deben ser publico.
019011=La clase "{0}" utilisa la clase de identidad {1} que tiene un campo {2}, pero el campo no existe en la clase {0}.
019012=La clase "{0}" ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} que es persistence-capable. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
019013=La clase "{0}" ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} pero debe ser {4}. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
019014=La clase "{0}" ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {1}.{2} tiene un tipo {3} que debe estar en /jdo/package/class/@objectid-class attributo para tipo {4}. e.g <class name="{4}" objectid-class="{3}"/>
019015=La clase "{0}" ha sido definido con el object-id class {1} que tiene {2} campos, mientras la clase ha sido definido con {3} campos en el "primary-key". El numero de campos en el objectidClass y el numero en el "primary-key" deben ser lo mismo.
019016=La clase "{0}" tiene una clave primaria {1} que esta invalido.

#
# Schema mapping, columns etc
#
020185=Field "{0}" should be using "subclass-table" inheritance strategy yet isnt. Please report this.
020186=El campo "{0}" esta declarado para usar algunas claves ajenas y tiene una especificacion de las columnas, pero el numero de columnas ({1}) no es igual que el numero de claves ajenas de este campo ({2}).
020187=Una columna añadido por el tipo "{0}" del campo "{1}" (declarada para usar "subclass-table")
020188=Una columna añadido por la implementación "{0}" del campo "{1}" (declarada como referencia - "interface" o java.lang.Object)
020189=¡El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) ("{1}") y debe tener una implementación "{2}", pero esta clase no existe!
020190=¡El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) y debe tener una implementación "{1}" pero este es Interface también!

#
# Query
#
021000=Tipo de parámetro incompatible : era {0}, pero debe ser {1} o una subclase
021001=El Query de JDOQL ha vuelto más que una instancia pero "unica" esta "verdad" o hay solo aggregados asi que debe devolver una como maxima.
021002=La declaración del import no es valido : {0}
021003=La declaración del package import no es valido : {0}
021004=La declaración del class import es duplicado : {0}
021005=La clase de los imports no existe : {0}
021006=Almacenando el hecho de que {0} no fuera encontrado por {1}
021007=Los tipos de Array son illegal : {0}
021008=Hay ambiguedad en la declaración de la clase ; puede ser {0} o {1}
021009=La clase de candidato "{0}" no existe!
021010=La clase {0} ha sido resuelto a {1}. Usted no la puso completamente en el Query y por eso podria evitar en look-up (y mejorar el rendimiento) si la ponga con nombre de paquete etc.
021011=Intento de invocar el metodo "{0}()" del objeto de tipo "{1}" - no lo apoyamos con este base de datos
021012={1} Query : Procesando la clausula "{0}" con evaluacion en memoria (clausula = "{2}")
021013=El Manager del Query esta cerrado!
021014=Esta Query no se puede cambiar. No puede cambiar su estructura.
021015=Query contiene nombre de una clase "{0}" (clase de candidato, clase de resultado, parametro, o variable) pero no esta resuelto. Por favor, compruebe el nombre y los imports.
021016=Query contiene acceso de "{0}" pero este campo/propiedad no existe!
021017=Query no tiene un Manager
021018=La ejecución del query "{0}" no ha completado antes que el timeout de {1}ms
021019=El query "{0}" empiece en un su propio hilo con el timeout de {1}ms
021020=El query "{0}" ha sido cancelado
021021=Un error ha ocurrido durante la ejecución del query "{0}"
021022=El query "{0}" empiece en un su propio hilo sin timeout
021023=Evaluación del filtro para candidado="{0}" da éxito
021024=Evaluación ha encontrado el variable="{0}" sin valor, y debe tener un valor del "{1}"
021025=Evaluación para variable="{0}" con valor de "{1}"
021026=Evaluación ha procesado todos los valores para el variable¡"{0}" y quita su valor.
021027=Query tiene que borrar objetos, pero hay un orden. No se puede poner el orden si es para borrar instancias.
021028=Query tiene que borrar objetos, pero hay un grupo. No se puede poner el grupo si es para borrar instancias.
021029=Query tiene que borrar objetos, pero el resultado existe. No se puede poner el resultado si es para borrar instancias.
021030=Query tiene que borrar objetos, pero la clase de resultado existe. No se puede poner la clase de resultado si es para borrar instancias.
021031=Query tiene que borrar objetos, pero tiene alcance de resultado. No se puede poner el alcance de resultado si es para borrar instancias.
021032=Query tiene "unique", pero el resultado contiene más que un objeto. No se puede poner "unique" si hay más que un objeto por ser borrado.

021034=No soportamos los query del lenguaje "{0}" para la base de datos "{1}"

021038=Esta implementación de JDOQL no da soporte a bulk update
021039=Esta implementación de JDOQL no da soporte a bulk delete
021040=Esta implementación de JPQL no da soporte a bulk update
021041=Esta implementación de JPQL no da soporte a bulk delete
021042=Ha tirado una excepción en la ejecucion del query : {0}
021043=Error con la extracción de resultados por el Query "{0}"

021044=Query de {0} : Compilación de "{1}"
021045=Query de {0} : Tiempo de compilar = {1} ms
021046=Query de {0} : Ejecucion de "{1}" ...
021047=Error en la ejecucion de Query de {0} - "{1}" : {2}.
021048=No hay una clase de candidato por el Query de {0}
021049=No era posible encontrar el campo "{0}" en la clase de candidato. Es posible que este campo es un campo en una subclase, pero es illegal usar campos de las subclases directamente.
021050=El filtro de Query "{1}" no da un resultado de boolean

021053=La clase "{0}" en una expresión (cast) no existe. Por favor compruebe que la clase esta en el CLASSPATH y esta en los imports del Query.

021054=El Query de {0} contiene una expresión invalida
021055=Query tiene algunas parametros declarados ("{0}"), pero hay por lo menos un parametro implicito ("{1}"). Es invalido. Usted debe declarar todos los parametros (explicito), o usar todos los parametros con un prefix :.
021056=Query tiene un parámetro implicito "{0}" (en posición {1}) ¡pero no había un valor disponible para esta posición!

021057=El uso de "new" en {0} debe seguir con el nombre de la clase, pero {1} no existe. Por favor, compruebe la lista de "imports".
021058=El uso de "new" en {0} debe seguir con el nombre de la clase y los argumentos del constructor pero esta incorrecta en "{1}".

021049=No era posible encontrar el campo "{0}" en la clase de candidato. Es posible que este campo es un campo en una subclase, pero es illegal usar campos de las subclases directamente.
021060=Error conectando el variable "{0}" a "{1}" como estaba conectado a "{2}" antes.
021061=El variable "{0}" no esta conectado al Query de JDOQL.

021064=The range {0} expression accepts only Literal values. Either define it as parameter or a literal. The current value is {1}.
021065=The range {0} expression expects a number, but it currently is {1}.
021066=No era posible encontrar la clase "{0}". Por favor, compruebe que la clase existe en el CLASSPATH.
021068=El parametro de Query ("{0}") esta conectado a otro Manager. Es imposible usar este Query asi.
021069=El "ORDER BY" tiene una expresión de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el "ORDER BY" tiene que estar tambien en el "GROUP BY".
021070=El resultado tiene una expresión de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el resultado tiene que estar tambien en el "GROUP BY".
021071=El "HAVING" tiene una expresión de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el "HAVING" tiene que estar tambien en el "GROUP BY".
021051=La expresión de "HAVING" "{0}" no es valido. Debe ser una expresión Boolean.
021072=Collección de candidatos esta vacia!
021074=Query de {0} : Tiempo de ejecutar = {1} ms
021075=Na cacheamos la compilación de la base de datos como necesitamos los valores de algunos parametros para compilarlo

021079=Query "{0}" de lenguaje "{1}" existe, por eso utilizamos la compilacion general de antes.
021080=Query "{0}" de lenguaje "{1}" para la base de datos "{2}" existe, por eso utilizamos la compilacion de datastore de antes
021081=Query "{0}" tiene {1} resultados. Vamos a ponerlos en el cache.
021082=Query "{0}" existe en el cache de resultados de query con {1} resultados. Vamos a utilisarlos

021083=Query de {0} : Compilación de "{1}" para base de datos
021084=Query de {0} : Tiempo de compilar para base de datos = {1}
021085={0} Query compilado para base de datos a "{1}"

# Query : Parameters/Variables
021101=Query tiene una lista de parametros que esta incorrecta "{0}"
021102=Query tiene un parametro "{0}" que esta incorrecta
021103=Query tiene dos o mas parametros con nombre "{0}"
021104=Query tiene una lista de variables que esta incorrecta "{0}"
021105=Query tiene un variable "{0}" que esta incorrecta
021106=Query tiene un variable "{0}" que es lo mismo que un parametro
021107=Query tiene dos o mas variables con nombre "{0}"
021108=Query hace falta {0} parametros, pero tiene {1}.
021109=The parameter {0} expected the argument value of primitive type {1}.
021110=El Query de {0} hace falta un parametro "{1}" pero no esta
021111=Query tiene algunas variables declarados ("{0}"), pero hay por lo menos un variable implicito ("{1}"). Es invalido. Usted debe declarar todos los variables explicito, o usar todos los variables como implicito.
021112=Query contiene un parametro "{0}" pero no hay ningun valor especificado al ejecutar el Query!
021113=Query tiene un valor por el parametro "{0}" pero este parametro no existe en el Query!
021114=Query tiene parametro "{0}" como un {1} pero esta comparado con un {2}. Los valores de parametros deben ser consistente con lo que se compare.
021115=Query tiene un subquery pero no hay declaracion de variables! Un subquery tiene que pasar su valor al Query principal por un variable
021116=Query tiene el parametro "{0}" provisto al ejecucion pero este query no lo utiliza!
021117=Query tiene el parametro "{0}" definido como "{1}" pero el valor es nulo!
021119=Query tiene el parametro "{0}" definido pero usted no ha entrado un valor en el metodo execute()

# Query : Result
021201=El Query va a volver con mas que un campo pero la clase de resultado es de un tipo simple ({0}). Son inconsistentes.
021202=El Query va a volver con un campo pero no es de la clase de resultado ({0}) : es {1}
021203=El Query tenia que devolver objetos de tipo "{0}" pero era imposible. Por favor compruebe que esta clase esta corecta por JDO.
021204=El Query tenia que devolver objetos de tipo "{0}" pero era imposible poner el valor al campo "{1}"  tipo "{2}". El campo debe tener un metodo publico set/put o ser publico.
021205=El Query tenia que devolver objetos de tipo "{0}" pero era imposible crear nueva instancia de este tipo! La clase de resultado necesita un constructor sin argumentos.
021206=La clase de resultado "{0}" no tiene un constructor con arguments de tipos {1}
021207=La clase de resultado "{0}" no tiene un metodo publico "void {1}({2})".
021208=La clase de resultado"{0}" no tiene un metodo publico "void {1}(Object, Object)".
021209=La clase de resultado "{0}" no tiene un campo publico "{1}"
021210=La clase de resultado no permite nombres de campos en mayusculos o menusculos; tiene que ser escrito corecto. Por ejemplo, el campo "{0}" esta mal escrito.
021211=El query tiene campo de resultado "{0}" de tipo "{1}" pero el tipo en la clase de resultado es "{2}"!
021212=El query tiene clase de resultado "{0}" pero no hay ninguna manera de poner el campo "{1}"!

# Query Cache
021500=Cache de Query "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
021501=Cache de Query "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
021502=Cache de Query del tipo "{0}" inicializada

#
# Api Adapter
#
022000=Error : Un error ocurrio cuando creando un adaptador "{0}" (quizas no tengas el jar apropiado datanucleus-api-XXX en el CLASSPATH, o el 'api' jar para la especificacion que utilisas?) : {1}
022001=Error : No se puede encontrar el API {0}. Quizas no tengas el jar apropiado datanucleus-api-XXX en el CLASSPATH?

#
# SCO
#
023000=El tipo de parámetro solicitado por el campo "{0}" : era {1} pero debe ser {2}
023001=El campo {0} no puede ser nulo en objeto "{1}"
023002=El contenedor (Collection/Map) no es preguntable como no tiene dueño que es un objeto de primera clase
023003=Creado SCO wrapper por objeto "{0}" campo "{1}" con {2} valores, con las opciones="{3}"
023004=El objeto "{0}" campo "{1}" ha sido reemplazado por un SCO wrapper de tipo "{2}" {3}
023005=El objeto "{0}" campo "{1}" enviando cambios del contenedor de SCO a la base de datos
023006=El objeto "{0}" campo "{1}" obteniendo los contenidos al contenedor de SCO de la base de datos
023007=El objeto "{0}" campo "{1}" va a ser inicializado por un contenedor con {2} valores
023008=El objeto "{0}" campo "{1}" va a ser cambiado por un conteneder con {2} valores
023009=Es imposible persistir el objeto "{0}" como esta manejado por otro persistence manager
# needs updating
023011=La clase {0} no tiene soporte como objeto de clase segundo (SCO)
023012=El campo "{0}" debe usar un comparator de clase "{1}" pero esa clase no existe en el CLASSPATH. Por favor compruebe el nombre de la clase de comparator.
023013=Execución del metodo "{0}" en el campo "{1}" ha causado un error : {2}
#
# Plugin
#
024000=File {0} doesn't exist. Check your path or classpath.
024001=Error reading plug-in file {0} : {1}
024002=Extension Point "{0}" not registered, but plugin "{1}" defined in {2} refers to it.
024003=Loading extension points from plug-in file {0}.
024004=Loading extensions from plug-in file {0}.
024005=Plugin Registry "{0}" no existe. Usando registry de DataNucleus

024007=Error en la registración del Bundle como el URL al MANIFEST.MF es nulo
024008=Error en leer el manifest "{0}"
024009=El plugin (Bundle) "{0}" ya esta registrado. Por favor compruebe que usted no tiene otras versiones del mismo plugin en el CLASSPATH. El URL "{1}" esta registrado, y intenta registra otro al URL "{2}."
024010=Error en la creación del URL para el plugin MANIFEST "{0}"
024011=Error en leer el MANIFEST.MF for "{0}"
024012=No se puede encontrar el fichero MANIFEST.MF para el plugin "{0}". Vamos a ignorarlo
024013=Bundle "{0}" tiene una dependencia opcional a "{1}" pero no se puede resolverla
024014=Bundle "{0}" se hace falta "{1}" pero no se puede resolverla
024015=Bundle "{0}" se hace falta "{1}" versión "{2}" pero ese bundle tiene versión "{3}" que esta fuera de los versiones aceptadas.
024016=Error en la creacion del DocumentBuilder : {0}
#
# CallbackHandler
#
025000=Error : Un error ocurrio cuando creando un CallbackHandler "{0}" : {1}
025001=Una excepcion ha sido tirado por el callback del usuario "{0}".
#
# StateManager
#
026000=No hay bastante acceso a org.datanucleus.*
026001=Desconectando del clono {0} de {1}
026002=El campo {0} de la clase {1} no existe
026003=Cambiar el StateManager da un error
026004=Desconectar el StateManager da un error
026005=Vaciando el StateManager de {0}
026006=El metodo no tiene soporte
026007=No es posible compartir SCO's con dueños; objeto doñado por campo {0} del objeto {1}
026008=Recurrente llamada a deletePersistent()
026009=Recurrente llamada a flush()
026010=Objeto tiene el estado ´sucio´´ pero ¡no hay campos sucios!
026011=Disconectando {0} de {1}
026012=No puede persistir la clase {0}
026013=Objeto no existe (identidad="{0}")
026014=La clase "{0}" del objeto con id "{0}" na ha sido encontrado
026015=La clase {0} no esta ! Por favor, comprueba usted que la clase existe en el CLASSPATH.
026016=The primary-key field {0} is null.
026017=Un objeto de la clase "{0}" usa SingleFieldIdentity con el campo "{1}" pero el campo no tiene ningun valor! Usted debe poner un valor, o usa "value-strategy" con este campo.
026018=La clase "{0}" no ha sido registrada. Por favor compruebe que esta analizada.
026019=No podemos crear una instancia de la clase "{0}". Si es "abstract", usted tiene que comprobar que no hay una fila por esa clase en la base de datos sin una fila en la tabla de una subclase.
026020=El campo "{0}" tiene value-strategy de "{1}" pero el tipo del campo no esta correcta usarlo.
026021=El campo "{0}" del objeto "{1}" ha sido registrado para actualización cuando su valor PC ("{2}") esta en la base de datos.
026022=Vamos a actualizar el valor del campo "{0}" del objeto "{1} como su valor PC ("{2}") ya esta en la base de datos.
026023=No podemos "detach" al objeto de tipo "{0}" y con identidad "{1}" porque ha sido borrado!
026024=No podemos "detach" el objeto de tipo "{0}" y con identidad "{1}" porque ya es "detached"!
026025=El "detach" del objeto de tipo "{0}" y con identidad "{1}" ha fallado. Por favor, compruebe el Log para alguna detalle.
026026=Vamos a borrar el objeto "{0}" porque esta el valor en un campo ({1}) donde el valor has sido anulado y el campo es delete-dependent.
026027=Una transition ilegal "{0}" ha sido intentado desde el estado "{1}", sm = "{2}"
026028=El objeto "{0}" ha sido marcado para persistir pero vamos a persistir a la base de datos mas tarde debido a transacción optimistic o "datanucleus.flush.mode" propiedad
026029=El objeto "{0}" (id="{1}") va a tener el valor en el campo "{2}" cambiado por un SCO wrapper
026030=El objeto "{0}" (id="{1}") va a tener el SCO wrapper en el campo "{2}" cambiado por el valor
026031=El objeto "{0}" (id="{1}") va a ser detachado (con la opcion DetachAllOnCommit?) pero no es detachable, por eso vamos a hacerlo transient
026032=El objeto "{0}" (id="{1}") tiene una valor cargado en campo {2} que esta fuera del FetchPlan. Descargandolo.
026033=El objeto "{0}" (id="{1}") va a tener los campos siguientes almacendados en el objeto de Level 2 cache : {2}
026034=El objeto "{0}" (id="{1}") va a tener los campos siguientes cargados del objeto de Level 2 cache : {2}
#
# LifeCycle states
#
027000=No se puede leer los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalRead=true'.
027001=No se puede escribir los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalWrite=true'.
027002=No se puede leer los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalRead=true'.
027003=No es posible cambiar el estado del objeto a nontransaccional como es nuevo, borrado y no esta comitido
027004=No es posible cambiar el estado del objeto a transitorio como es nuevo, borrado y no esta comitido
027005=No es posible leer campos de un objeto borrado
027006=No es posible escribir campos de un objeto borrado
027007=No es posible cambiar el estado del objeto a nontransaccional como esta borrado
027008=No es posible cambiar el estado del objeto a transitorio como esta borrado
027009=No es posible leer campos de un objeto borrado
027010=No es posible escribir campos de un objeto borrado
027011=No es posible cambiar el estado del objeto a nontransaccional como es sucio
027012=No es posible cambiar el estado del objeto a transitorio como es sucio
027013=No es posible cambiar el estado del objeto a nontransaccional como no es nuevo y no esta comitido
027014=No es posible cambiar el estado del objeto a transitorio como es nuevo y no esta comitido
027015=El campo no esta copiado al objeto "detached". Usted tiene que añadirlo al FetchPlan y "detach" el objeto otra vez.
027016=Objeto "{0}" (id="{1}") tiene cambio de lifeycle : "{2}"->"{3}"
#
# XML Parser
#
028000=XML Entity Public="{0}" System="{1}" : con source local "{2}"
028001=XML Entity Public="{0}" System="{1}
028002=resolveEntity({0}, {1}) no existe
028003=resolveEntity({0}, {1}) ha fallado!
#
# SingleFieldIdentity
#
029000=No era posible construir una identidad de SingleFieldIdentity de tipo "{0}" porque la clase dado es nulo
029001=El tipo de identidad para construir una identidad de SingleFieldIdentity para la clase "{0}" es nulo
029002=El tipo de identidad ("{0}") dado para construir una identidad de SingleFieldIdentity para la clase "{1}" no es valido.
029003=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" para la clase "{1}" es nulo.
029004=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" de la clase "{1}" es de un tipo invalido ("{2}") - debe ser "{3}".
#
# Utils
#
030000=Todavia espero el read lock por {0}
030001=Ya el Thread tiene un read lock
030002=Todavia espero el write lock por {0}
030003=El formato de Timestamp no esta mal: "{0}" - debe ser yyyy-mm-dd hh:mm:ss.fffffffff
030004=Un constructor de la clase {0} no existe, parametros {1} 
030005=Error cuando intentando usar la clase {0}
030006=Error intentando crear un objeto de la clase {0}
030007=Excepcion tirado por constructor por {0}, {1}
#
# RDBMS Views/Macros
#
031000=Incomparable puntales para el macro de interrogacion: {0}
031001=Incomparable punto de interrogacion para el macro de parametro: {0}
031002=No puede parsar macro de identificacion: {0}
031003=Hay una dependencia circular entre las visiones

#
# Store Manager
#
032000=No hay un StoreManager disponible : {0}
032001=Va a manjejar la persistencia de {0}
032002=Desmanejando la persistencia de todas las clases
032003=Manejando la persistencia de {0} porque era manejado antes

032004=Intenta de poner/cambiar/borrar objeto "{0}" en una base de datos que es para leer. Usted ha puesto esta base de datos "read-only" con la propiedad de persistencia "org.datanucleus.readOnlyDatastore". Debe quitar esta propiedad si quiere poner objetos alli.
032005=Intenta de poner/cambiar/borrar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.
032006=Intenta de poner/cambiar/borrar objeto "{0}" para una clase que es para leer. Usted ha puesto esta clase "read-only"
032007=Intenta de poner/cambiar/borrar objeto "{0}" para una clase que es para leer. Vamos a ignorarlo.

032010=Intenta de borrar objeto "{0}" dependiente de objeto en una base de datos que es para leer
032011=Intenta de borrar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.

032012=La clase "{0}" es "embedded-only" asi que no tiene su propia tabla.
032013=La clase "{0}" usa la estrategia "subclass-table" y no hay una subclase o superclase que tiene una tabla.
032014=La clase "{0}" usa la estrategia {1} y no hemos encontrado una tabla para persistirla.
032015=Intenta obtener el nombre de la tabla de base de datos por una clase nula !

032013=La clase {0} usa estrategia de "subclass-table" pero ningun subclase tiene una tabla definida.

032016=Objeto "{0}" (id="{1}") ha sido cambiado en la base de datos después de la ultima leer. Base de datos tiene version "{2}" pero la transacción tiene version "{3}"
032017=La clase "{0}" tiene estrategia de versiones de "{1}" pero JPOA no la apoya ahora mismo. Por favor compruebe la documentación para las estrategias que apoyamos.

032018=Registrado la factoria de connecciones transaccionales bajo el nombre "{0}"
032019=Registrado la factoria de connecciones nontransaccionales bajo el nombre "{0}"

032020=StoreManager : "{0}" con el URL "{1}" - datastore-mode={2}

#
# Extent
#
033000=No se puede crear el Extent porque tiene que dar el nombre de la clase.
033001=No se puede crear el Extent de la clase "{0}" porque no hay Meta-Data disponible para esa clase.
033002=El Extent de {0} incluso los subclases={1}
033003=Query sobre Extent nunca va a dar resultado sin subclases : extent= {0}, clase={1}

#
# Auto Starter
#
034000=Error en la inicialisación de DataNucleus : Una clase "{0}" estaba en la lista de persistencia de este esquema pero no la existe. Quizas es de otra aplicación de DataNucleus usando la misma esquema, o has cambiado los nombres de las clases.
034001=Borrando la clase {0} de la lista de clases manejadas
034002=Unknown Error during auto starter execution. : {0}
034003=Illegal state of AutoStart, disabling it. To enable it, resolve earlier errors.
034004=Error en la inicialisación de DataNucleus: una clase "{0}" estaba en la lista de persistencia de este esquema pero ya no tiene MetaData disponible.
034005=AutoStart Mechanism "{0}" empezando
034006=AutoStart Mechanism "{0}" terminado

034100=Mecanismo de AutoStart con clases. Tiene que poner una lista de clases en la construcción del PMF.
034150=Mecanismo de AutoStart con MetaData. Tiene que poner una lista de archivos de MetaData en la construcción del PMF.

034200=Mecanismo de AutoStart de XML. Almacena su definición en un fichero de XML
034201=El fichero de XML AutoStarter {0} no existe. Creandolo ...
034202=Error leer el fichero de XML AutoStart {0} : {1}
034203=Error escribir el fichero de XML AutoStart {0} : {1}
034204=resolveEntity({0}, {1})

#
# Store Data
#
035000=El MetaData no puede ser nulo : tabla = {0}
035001=La tabla no puede ser nulo
035002=Clase : {0}
035003=Campo : {0}
035004=Clase : {0} [Tabla : {1}, Estrategia de heredar : {2}]
035005=Campo : {0} [Tabla : {1}]

#
# Datastore Adapter
#
036000=El constructor {0}(ClassBaseTable,int) no existe
036001=Campos del tipo {0} no tienen soporte
036002=Puede usa {0} con un campo persistence-capable solamente
036003=Datastore Mapping mappings have been defined to be in file "{0}" yet this file can't be found in the classpath.

#
# JDOQL Expressions
#
037000=No se puede navegar el campo "{0}" en "{1}". Debe hacer un Cast este Interface a un tipo concreto y intentarlo otra vez.
037001=Query tiene una referencia al campo "{0}", pero la tabla del Query "{1}" no tiene ninguna columna por este campo
037002=Query tiene una referencia al campo "{0}" pero el campo "{1}" no existe en el objeto del campo "{2}"
037003=Query tiene comparacion a un objeto "{0}" que no tiene identidad de JDO - quizas el objeto sea transient o embedded. Siempre devuelve nada.
037004=Query tiene comparacion con una collecion qu no es nulo. DataNucleus no lo apoya.

037005=Query tiene una referencia al campo "{0}" pero la clase usa "subclass-table" estrategia de heredar y no hay ninguna subclase de esa clase. No podemos crear un Query de JDOQL.
037006=Query tiene una referencia al campo "{0}" per la clase usa "subclass-table" estrategia de heredar. DataNucleus apoya una relacion 1-1 con "subclass-table" si hay una subclase sola, pero aqui hay mas! Vamos a usar "{1}"
037007=Intenta de comparar el "instanceof" de un objeto con una expressión de tipo "{0}". JDOQL solo permita la comparación con una clase.

037008=Intenta de usar el método "{0}" de la clase "{1}", pero el método no es public static final. No lo apoyamos en JDOQL.
037009=Intenta de usar el método "{0}" de la clase "{1}", ¡pero no lo existe!
037010=El operador de JDOQL "instanceof" tiene clase "{0}", pero no la encontramos. Por favor, compruebe que la clase esta puesta correctamente.

037011=Intenta de invocar la expresión "{0}" con un argumento que no es numerico. Esta expresión acepta solo argumentos de tipo numerico.
037012=Intenta de usar "DISTINCT" con la expresión "{0}". No es posible con esta función.

037013=Query de JDOQL tiene una expresión para construir un objeto de la clase "{0}" con un constructor que no existe! Por favor, corrigelo.
037014=Intenta de crear un objeto nuevo usando un constructor con "{0}" valores pero necesita "{1}"
037015=Error en la creación de un objeto nuevo de "{0}" : {1}

037016=Query tiene instanceof de "{0}" que es una clase desconocida
037017=Query tiene cast de "{0}" que es una clase desconocida

#
# OID
#
038000=El valor del OID no es valido : {0}
038001=Identidad "{0}" puesto a la clase {1}, pero el tipo de object-id no esta correcta.
038002=Valor generado para el campo "{0}" con estrategia="{1}" (Generador="{2}") : valor={3}
038003=Identidad generado para el campo {0}, id : {1} es incorrecto
038004=No hay ningun generador de valor para la estrategia "{0}" para este base de datos. Por favor, lee en la documentación sobre las estrategias que tiene soporte para este base de datos.
038005=El campo "{0}" ha sido especificado usar un TableGenerator pero no hay uno con nombre "{1}"
038006=El campo "{0}" ha sido especificado usar un SequenceGenerator pero no hay uno con nombre "{1}"

#
# Identifiers
#
039000=Caja de identificación "{0}" no esta apoyada. Por favor elige otra
039001=Factoria de identificaciones las queria en "{0}" pero el adaptador del base de datos no lo apoya. Ya usamos "{1}"
039002=Factoria de identificaciones las quiere en "{0}" pero es imposible con este adaptador de base de datos, y no hay otra opción.
039003=Factoria de identificaciones "{0}" no esta registrada! Por favor compruebe el CLASSPATH para el plugin que la contiene, y la especificacion de PMF.
039004=Factoria de identificaciones "{0}" esta registrada para usar la clase "{1}" pero no la existe. Por favor compruebe el plugin y CLASSPATH
039005=Factoria de identificaciones "{0}" ha tirado un error con construirla. Por favor compruebe la validez del plugin.

#
# Value Generators
#
040000=Era imposible crear un generador de identidades de tipo "{0}" : {1}
040001=Creando instancia de ValueGenerator de tipo "{0}" para "{1}"

040002=El repositorio de IDs es invalido
040003=Hemos encontrado un error en la allocación de un block de IDs : {0}
040004=Hemos reservado un bloque de {0} valores
040005=Creando repositorio de IDs en la base de datos ...
040006=El valor de "key-cache-size" ({0}) es invalido
040007=El valor de "sequence" ({0}) es invalido
040008=Hemos encontrado un error en la allocación de IDs : {0}
040009=El generador "{0}" no genera valores numéricos. Por favor llame a "next()" para obtener el valor como un Objeto.

040010=No podíamos crear el "sequence" {0} como los flags de "autoCreate" no estan puestos para permitirlo.
040011=No podíamos crear la tabla para value-generation de "increment"/"table" {0} como los flags de "autoCreate" no estan puestos para permitirlo.

#
# Mapping
#
041017=No es posible fijar la identidad de Application. Parámetro = {0}
041021=El objeto "{0}" tiene campo "{1}" con relacion bidirectional N-1 a "{2}" pero la collección "{3}" no contiene este objeto; lo vamos a añadir

041024=Error un la creación de la clase "{0}" : {1}
041025=Es imposible usar un Query con un campo serializado ("{0}"). Usted tiene que cambiar el Query, o cambiar el campo para ser no serializado.

041026=Es imposible usar un Query con un campo de array almacenado en una columna("{0}"). Usted tiene que cambiar el Query, o cambiar el campo para ser no almacenado asi.

041027=No puede poner el parametro de BigInteger : valor = {0}
041028=No puede obtener el resultado de BigInteger : param = {0}
041029=No puede poner el parametro de BigDecimal : valor = {0}
041030=No puede obtener el resultado de BigDecimal : param = {0}

041031=No puede poner el parametro de Object : valor = {0}
041032=No puede obtener el resultado de Object : param = {0}
041033=No puede obtener el resultado de URL : param = {0}, valor = {1}
041035=No era posible obtener el OID del objeto

041036=Error creating AID of type {0} : exception is {1}
041037=Error creating AID of type {0}, field {1}, value {2} : exception is {3}
041039=¡No podemos crear una identidad de SingleFieldIdentity porque la llave obtenido de la base de datos es nulo!

041040=El campo "{0}" esta serializado. DataNucleus no apoya la persistencia de campos de Interface como serializados.
041041=El campo "{0}" esta serializado. DataNucleus no apoya la persistencia de campos de Interface como "embedded".

041043=El campo "{0}" esta Object (non-serializado). DataNucleus no apoya la persistencia de campos de Object que no estan serializados.

041045=resolveEntity({0}, {1})
041046=¡Los mappings datastore están en el fichero "{0}", pero el fichero no existe!
041047=Los mappings datastore están en el fichero "{0}" pero había un error leerlo : {1}
041048=La clase de mapping datastore "{0}" no está. Por favor, compruebe la especificación de clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
041049=Datastore Mapping mappings have been defined to be in file "{0}" yet this file can't be found in the classpath.

041051=Un error ha sido tirado "{0}" para el valor {1} y la columna "{2}" : {3}

#
# JDOQL
#
042000=No se puede usar Query con Extent de la clase {0}
042001=No hay una clase de candidato por el Query de JDOQL
042002=El filtro de Query de JDOQL "{0}" no da un resultado de boolean
042003=El orden de Query de JDOQL "{0}" contiene una expresión que no esta corecta
042004=El orden de Query de JDOQL "{0}" contiene una dirección que no esta corecta. Debe ser "ascending", "descending", "asc", "desc".
042005=El Query de JDOQL incluye un parametro "{0}"pero no hay una declaración de este en la lista de parametros.
042006=El Query de JDOQL hace falta {0} parametros, pero hay solamente {1}
042007=Error usando Query de JDOQL "{0}" : {1}.
042009=El Query contiene la identificación "{0}", pero este es una palabra clave de JDOQL. El Query no es valido.
042008=El query ("{0}") tiene operador de assignar ("=") pero no existe en JDOQL. ¿La intención era usar el operador '==' para comparar dos objetos?

042010=JDOQL Single-String de "{0}"
042011=El Query contiene una palabra clave de JDOQL ("{0}") pero no esta en su debido posición. Usted puede poner las palabras claves en una orden definido en la especificación de JDOQL.
042012=JDOQL Single-String Query tiene que empezar con SELECT
042013=JDOQL Single-String Query tiene la palabra clave "{0}" pero es illegal con "{1}" después.
042014=JDOQL Single-String Query tiene la palabra clave "{0}" pero no tiene valor. Debe tener "{1}" despues de "{0}".
042015=JDOQL Single-String expects the keyword "{0}" after the keyword "{1}"
042016=JDOQL Single-String Query tiene clase "{0}" pero no existe. Por favor compruebe que la clase esta en el CLASSPATH
042017=JDOQL Single-String Query tiena una clausula de subquery pero no cierre el parentesis

#
# JPQL
#
043000=JPQL Single-String de "{0}"
043001=El Query de JPQL contiene una palabra clave ("{0}") pero no esta en su debido posición. Usted puede poner las palabras claves en una orden definido en la especificación de JPQL.
043002=JPQL Single-String Query tiene que empezar con SELECT/UPDATE/DELETE
043003=JPQL Single-String Query tiene la palabra clave "{0}" pero es illegal con "{1}" después.
043004=JPQL Single-String Query tiene la palabra clave "{0}" pero no tiene valor. Debe tener "{1}" despues de "{0}".
043005=JPQL Single-String expects the keyword "{0}" after the keyword "{1}"
043006=JPQL Single-String Query tiene clase "{0}" pero no existe. Por favor compruebe que la clase esta en el CLASSPATH
043007=JPQL UPDATE/DELETE query no puede tener una clausula de GROUP BY
043008=JPQL UPDATE/DELETE query no puede tener una clausula de HAVING
043009=JPQL UPDATE/DELETE query no puede tener una clausula de ORDER BY
043010=JPQL UPDATE Query no tiene una clausula de UPDATE! Query debe ser como "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"
043011=JPQL UPDATE Query tiene clausula de UPDATE pero no hay SET! Query debe ser como "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"

#
# MetaData
#
044001=Clase "{0}" campo "{1}" : MetaData tiene atributo "{2}" con valor "{3}" pero acepta "{4}"
044002=MetaData extension "{0}" acepta valores de "{1}" pero tiene valor de "{2}"!
044003=Clase "{0}" campo "{1}" : Tiene una collección pero no hay ningun tipo de elemento en el MetaData ni es posible inferirlo por generics, usamos Object
044004=Clase "{0}" campo "{1}" : Tiene un mapa pero no hay ningun tipo de clave-valor en el MetaData ni es posible inferirlos por generics, usamos Object

044005=MetaData Management : Carga de Metadata de los archivos de metadata "{0}" ...
044006=MetaData Management : Carga de Metadata de las clases "{0}" ...
044007=MetaData Management : Carga de Metadata del persistence-unit "{0}" ...
044008=MetaData Management : Carga de Metadata del usuario ...
044009=MetaData Management : Carga de Metadata del jar "{0}" ...
044010=MetaData Management : Carga de Metadata ya ha terminado
044011=No se puede crear Scanner para los metadatos, el tipo de valor no tiene soporte: {0}
044012=No se puede crear una instancia del Scanner: {0}
044013=MetaData Management : Inicialisando con los archivos de MetaData y clases
044014=MetaData Management : Inicialisación con los archivos de MetaData y clases ya ha terminado
044015=El archivo de MetaData "{0}" no contiene MetaData valido
044016=Hemos encontrado errores durante el proceso de leer los archivos de MetaData y clases. Compruebe por favor, las excepciones adjuntados
044017=La clase "{0}" no tiene MetaData o annotaciones.

044018=Populación del MetaData ...
044019=Inicialisación del MetaData ...
044020=Hemos encontrado errores durante la inicialisación de MetaData. Compruebe por favor, las excepciones adjuntados

044021=MetaData Management : Inicialisando con el persistence-unit "{0}"
044022=MetaData Management : Inicialisation con el persistence-unit "{0}" ya ha terminado
044023=Hemos encontrado errores durante el proceso de leer el MetaData del persistence-unit "{0}". Compruebe por favor, las excepciones adjuntados
044024=Hemos encontrado errores durante el proceso de leer el MetaData del jar "{0}". Compruebe por favor, las excepciones adjuntados

044025=Metadata para el campo "{0}" intenta cambiar el primary-key de la definicion de metadata "root" (annotaciones o archivo ".jdo" XML). Tiene que especificar primary-key en la definicion de metadata "root"

044026=Clase "{0}" descubierto para ser parte del persistence-unit "{1}"; cargandolo
044027=El Persistence-Unit "{0}" contiene una referencia a mapping-file "{1}" pero era imposible leerlo - {2}
044028=El plugin de MetaData handler "{0}" no existe en el CLASSPATH. Por favor compruebe el CLASSPATH y la especificaión de plugin.
044029=Error creando handler del tipo "{0}" para analizar el MetaData : {1}
044030=Analizando el MetaData "{0}" con handler "{1}" (validar="{2}")

044031=¡Intenta de analizar un archivo que era nulo!
044032=Error en abrir el archivo de Meta-Data "{0}"
044033=No puede leer Meta-Data input "{0}"

044034=Clase "{0}" define {1} campos de primary-key pero su superclass tiene {2} campos de primary-key; no se puede agregar mas campos de primary-key!

044036=El tag "{0}" no puede tener el tag padre "{1}" : debe ser {2}
044037=El tag es desconocido : "{0}"
044038=Error en el analizo del archivo "{0}" a la linea {1} : {2} - Por favor compruebe el DTD y la validad de este MetaData.
044039=Error en el analizo del archivo "{0}" a la linea {1}, columna {2} : {3} - Por favor compruebe el DTD y la validad de este MetaData.
044040=Error en el analizo del archivo "{0}" tiene causa {1}
044041=A value is expected in the attribute "{0}" for "{1}" in element "{2}". 

044042=Un error ha ocurrido durante el analisis de <"{0}"> dentro de "{1}" para el URI "{2}"

044043=Registrando la clase "{0}" no tener Meta-Data
044044=Deregistrando la clase "{0}" no tener Meta-Data - ya vamos a añadir el Meta-Data
044045=El archivo "{0}" contiene metadata de tipo "{1}" pero debe contener del tipo "{2}". Vamos a ignorarlo
044046=No hemos encontrado ningun archivo "persistence.xml" en el CLASSPATH. Debes poner esos ficheros en la carpeta META-INF/ de los JARs.
044047=No hemos encontrado el Persistence-Unit "{0}" en los archivos "persistence.xml" disponibles.

044048=No hemos encontrado el MetaData del tipo "{0}" por la clase "{1}"
044049=No encontramos el MetaData del tipo "{0}" por la clase "{1}" en {2}
044050=No encontramos el MetaData por la query {0} en {1}
044051=No encontramos el MetaData por la secuencia {0} en {1}
044052=El MetaData del tipo "{0}" por la clase "{1}" sera {2}
044053=El MetaData por la query {0} sera {1}
044054=El MetaData por la secuencia {0} sera {1}
044055=El analizo del archivo de MetaData {0} falló
044056=El archivo "{0}" va a tener su definición internal de MetaData aumentado con información de ORM MetaData
044057=The package name in empty in MetaData file {1}.
044058=The package {0} has an empty MetaData specified for a class name. Please check the file {1}.
044059=Encontro el Meta-Data de la clase {0} pero la clase no esta analizado! Por favor, debes analizar la clase antes de usar DataNucleus.
044060=Clase "{0}" campo "{1}" : añadiendo el Meta-Data por el campo como no estaba en la definición de Meta-Data.
044061=El elemento de Meta-Data "class" por package {0} necesita un 'name' attributo.

044063=Clase "{0}" : esta especificada como persistable pero es Inner y no es estatico. Clases asi no pueden ser persistable.
044064=Clase "{0}" tiene estrategia de heredar como \"superclass-table\" pero no hay ninguna superclase con su propia tabla. Duhhhhhhh

044065=Clase "{0}" : va a usar "application identity", no hay "objectid-class" en la definición, pero hay {1} campos de primary-key. No podemos usar SingleFieldIdentity.
044066=Clase "{0}" : va a usar "application-identity", no hay "objectid-class" y hay un campo de PK , pero el campo es de un tipo invalido {1} por SingleFieldIdentity. Puede usar los tipos short, Short, int, Integer, long, Long, byte, Byte, char, Character, o String.
044067=Clase "{0}" : No hay un class loader especificado por cargar las classes del MetaData de esta clase. Usando el default ClassLoader.
044068=Clase "{0}" : No puede popular la clase como es populado
044069=Clase "{0}" : MetaData no ha sido inicializado por la clase
044070=Clase "{0}" : MetaData no ha sido populado por la clase
044071=Clase "{0}" campo "{1}" : definido en el MetaData, pero este campo no existe en la clase!
044072=Clase "{0}" tiene metodo {1} definido en el MetaData, pero este metodo no existe en la clase!
044073=Clase "{0}" tiene propiedad {1} definido en el MetaData, pero el "getter" metodo no existe en la clase!
044074=Clase "{0}" tiene propiedad {1} definido en el MetaData, pero el "setter" metodo no existe en la clase!

044075=Clase "{0}" : Populando Meta-Data
044076=Clase "{0}" : Inicializando Meta-Data

044077=Clase "{0}" ha sido definido con el object-id class {1} pero no hay ningun campo como "primary key". Por favor debes anotar con el tag "primary-key" los campos usar como parte de la llave primaria
044078=Class "{0}" has been specified with {1} primary key fields, but this class is using {2} identity and should be application identity.

044079=Clase "{0}" ha sido definido con el object-id class {1}. La clase no existe. Por favor, compruebe la especficación o CLASSPATH.
044080=Clase "{0}" tiene MetaData pero la clase no existe. Por favor compruebe la especificación de CLASSPATH.
044081=Clase "{0}" ha sido definido con un persistence-capable-superclass {1} pero no existe.
044082=Clase "{0}" ha sido definido con un persistence-capable-superclass {1} que no es un superclass de esa clase.
044083=Clase "{0}" ha sido definido con un persistence-capable-superclass {1} que no es Persistence-Capable (no hay Meta-Data).
044087=Clase "{0}" : El persistence-capable-superclass tiene que ser la clase {1}, y no la clase {2}.
044088=Clase "{0}" : El persistence-capable-superclass {1} no se puede encontrar. Por favor compruebe la especificación de CLASSPATH.
044089=Clase "{0}" : DataNucleus ha puesto un valor de persistence-capable-superclass "{1}"; no tenia valor en el MetaData.
044090=Clase "{0}" : ya tiene un campo con el nombre {1}.

044099=Clase "{0}" tiene una estrategia de heredar de SUPERCLASS, pero no hay una superclase!
044091=Clase "{0}" no tiene un persistence-capable-superclass, pero tiene una superclase "{1}" que ES persistable. Corrigalo por favor.

044093=Clase "{0}" : El tipo de identidad no es lo mismo que el tipo de identidad en la superclase.
044094=Clase "{0}" : La estrategia de Datastore-identity ("{1}") no es la misma que la estrategia de Datastore-Identity en la superclase ("{2}").

044095=Clase "{0}" va a tener su definición internal de MetaData aumentado con información de annotaciones
044096=Clase "{0}" va a tener su definición internal de MetaData aumentado con información de ORM MetaData
044097=Clase "{0}" tiene MetaData con implements {1} pero la clase no existe! Por favor compruebe el CLASSPATH y MetaData.
044098=Clase "{0}" tiene una estrategia de heredar de "{1}" pero apoyamos "{2}" solamente.
044099=Clase "{0}" tiene una estrategia de heredar de "superclass-table", pero no superclase existe o no existe con propia tabla
044100=Clase "{0}" tiene una estrategia de heredar de "superclass-table", usando la tabla {1}, pero esa clase no tiene un discriminador.
044101=Clase "{0}" tiene una estrategia de heredar de "superclass-table", usando la tabla {1}, pero esa clase no tiene una columna de discriminador
044102=Clase "{0}" tiene una estrategia de heredar usando la tabla de clase {1} con la columna de discriminador {2}. Esta clase no tiene un valor de discriminador
044103=Clase "{0}" usa la estrategia de discriminación de "value-map" pero no tiene valor. Vamos a usar el nombre de la clase!
044104=Clase "{0}" tiene una estrategia de "{1}" pero DataNucleus no la apoya. Usamos el "default"
044105=Clase "{0}" es abstracto pero tiene un valor de disriminador. No se va a usar el valor nunca!

044106=Clase "{0}" campo "{1}" : No puede popular el campo con un campo nulo.
044107=Clase "{0}" campo "{1}" : No puede popular el campo como ya ha sido populado.
044108=Clase "{0}" campo "{1}" : No puede cambiar el campo como ya ha sido inicializado.
044109=Clase "{0}" campo "{1}" : es definido como {2} con "persistence-modifier={3}" pero tiene "default-fetch-group=true" o "primary-key=true" definido! Deben ser falsos.
044110=Clase "{0}" campo "{1}" : esta declarado con atributo "dependent" pero es una coleccion, array o map y debes declarar dependent dentro de un elemento de "array", "collection" o "map", e.g. como "dependent-element" (para colecciones)
044111=Clase "{0}" campo "{1}" : No podemos persistir el campo porque es de un tipo de array que DataNucleus no apoya. Por favor, debe cambiarlo por una colección.
044112=Clase "{0}" campo "{1}" : ya existe, pero tiene otra definición.
044113=Clase "{0}" campo "{1}" : como de la clase "{2}" pero no hemos encontrado esta clase
044114=Clase "{0}" campo "{1}" : como de la clase "{2}" pero no es una superclase! Usted puede usar solamente los campos de las superclases que son persistable.
044115=Clase "{0}" campo "{1}" : tiene "mapped-by" de "{2}". Este campo no existe en el otro lado de la relación ("{3}")!!
044116=Clase "{0}" campo "{1}" : tiene "implementation-classes" pero la clase de implementación "{2}" no existe!!
044117=Clase "{0}" campo "{1}" : no se puede popular con un valor "{2}" para la propiedad "{3}".

044118=Class "{0}" campo "{1}" : marcado como persistente pero es "final" asi que no se puede persistirlo

044119=Clase "{0}" : Una columna sin campo ha sido especificado sin el nombre. Cualquier columna sin campo tiene que tener un nombre
044120=Clase "{0}" : Una columna "{1}" sin campo ha sido especificado sin el tipo de JDBC. Cualquier columna sin campo tiene que tener un tipo de JDBC

044121=Clase "{0}" campo "{1}" tiene tipo "{2}" pero es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser persistable.
044122=Clase "{0}" campo "{1}" es una collección de elementos de tipo "{2}" pero es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser persistable.
044123=Clase "{0}" campo "{1}" es una mapa con llaves de tipo "{2}" pero la llave es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser persistable.
044124=Clase "{0}" campo "{1}" es una mapa con valores de tipo "{2}" pero el valor es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser persistable.
044125=Clase "{0}" campo "{1}" : añadiendo el Meta-Data por el campo "embedded" en la clase "{2}" como no estaba en la definición de <embedded> Meta-Data.

044126=Clase "{0}" define columna de discriminador, pero hay esa informacion en una superclase! En general ignora esta definicion (salvo si ibas a tener una columna de discriminador en muchas tablas por un arbol de heredar).

044129=Clase "{0}" campo "{1}" tiene como "embedded" un objeto de tipo "{2}", pero es "interface" y lo has especificado con un CAMPO "{2}". Debe ser una PROPIEDAD.
044130=Clase "{0}" campo "{1}" tiene <join table="...">. El atributo "table" no tiene sentido cuando <join> esta dentro de <field>. En este caso usted debe poner "table" en <field>.
044131=Clase "{0}" campo "{1}" ha sido definido con <collection> y element-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "implementation-classes" extension de DataNucleus.
044132=Clase "{0}" campo "{1}" ha sido definido con el "collection" MetaData pero no es un campo de Collection.
044133=Clase "{0}" campo "{1}" ha sido definido como Collection pero el tipo de elemento no ha sido definido!
044134=Class "{0}" field "{1}" ha sido definido como Collection con elementos de tipo {2}. ¡Este tipo de elemento no existe!
044135=Class "{0}" field "{1}" ha sido definido como Collection con elementos de tipo {2}. Este tipo ha sido resuelto a  {3}

044137=Clase "{0}" campo "{1}" tiene mapped-by de <order> pero el campo ("{2}.{3}") no existe!
044138=Clase "{0}" campo "{1}" tiene ordering con un campo ("{2}.{3}") que no existe!
044139=Clase "{0}" campo "{1}" tiene ordering con una dirección invalida ("{2}"). Debe ser ASC o DESC
044140=Clase "{0}" campo "{1}" ha sido definido con <array> y element-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "implementation-classes" extension de DataNucleus.
044141=Clase "{0}" campo "{1}" ha sido definido con <array> MetaData pero no es un campo de array.
044142=Clase "{0}" campo "{1}" es una matriz de (non-serializado) elementos de tipo "{2}" pero no tiene ningun <join>. Para almacenar una matriz asi necesita una tabla de juntar, o marcarlo como "serialized".
044143=Clase "{0}" campo "{1}" ha sido definido con <map> y key-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "key-implementation-classes" extension de DataNucleus.
044144=Clase "{0}" campo "{1}" ha sido definido con <map> y value-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "value-implementation-classes" extension de DataNucleus.
044145=Clase "{0}" campo "{1}" ha sido definido con "map" MetaData pero no es un campo de Map.
044146=Clase "{0}" campo "{1}" ha sido definido como Map pero el tipo de key no ha sido definido!
044147=Clase "{0}" campo "{1}" ha sido definido como Map con keys del tipo {2}. ¡Este tipo de key no existe!
044148=Clase "{0}" campo "{1}" ha sido definido como Map con keys de tipo {2}. Este tipo de key ha sido resuelto a {3}.
044149=Clase "{0}" campo "{1}" ha sido definido como Map pero el tipo de value no ha sido definido!
044150=Clase "{0}" campo "{1}" ha sido definido como Map con values del tipo {2}. ¡Este tipo de value no existe!
044151=Clase "{0}" campo "{1}" ha sido definido como Map con values del tipo {2}. Este tipo de value ha sido resuelto a {3}.
044152=Clase "{0}" campo "{1}" tiene key-type como "{2}" que es tipo de referencia, y tiene "embedded". DataNucleus no apoya el uso de un tipo de referencia con "embedded".
044153=Clase "{0}" campo "{1}" tiene value-type como "{2}" que es tipo de referencia, y tiene "embedded". DataNucleus no apoya el uso de un tipo de referencia con "embedded".
044154=Clase "{0}" : ¡Query no tiene un nombre ! Por favor, cada Query necesita un nombre.
044155=Clase "{0}" : ¡Sequence no tiene un nombre ! Por favor, cada Sequence necesita un nombre.
044156=La estratagia no esta !
044157=La estratagia no esta !
044158=El factory-class {0} no esta !
044159=El factory-class {0} no hace javax.jdo.IdGenerator !
044160=La especificación del tag de <extension> no esta correcta. El vendor-name ({0}), key ({1}) y value ({2}) deben ser especificados.
044161=Clase "{0}" campo "{0}" : declarado como referencia ("interface" o java.lang.Object) but no hay clases de implementación de "{2}"
044162=Clase "{0}" campo "{1}" : declarado en metadata, pero no hay una superclase persistente con este campo

044200=Clase "{0}" tiene anotaciones de {1} y vamos a usarlas.
044201=Clase "{0}" tiene anotación "{1}" con propiedad "{2}" pero es invalido. Por favor compruebe la especificación para esta anotación.
044202=Clase "{0}" tiene anotaciones pero no hay ningún AnnotationReader registrado para este tipo de anotaciones. Por favor compruebe el CLASSPATH y las anotaciones para validez.
044203=Clase "{0}" tiene anotación "{1}" que no esta procesado aqui. Si sea un annotacion de extension de DataNucleus, lo procesamos mas tarde.
044204=Clase "{0}" : @Index especificado pero no hay campos/columnas asi que DataNucleus lo ignora
044205=Clase "{0}" : @Unique especificado pero no hay campos/columnas asi que DataNucleus lo ignora
044206=Clase "{0}" : @ForeignKey especificado pero no hay campos/columnas asi que DataNucleus lo ignora
044207=Clase "{0}" tiene especificación de @FetchPlan y @FetchPlans. Usted debe poner solo una
044208=Clase "{0}" tiene especificación de @FetchGroup y @FetchGroups. Usted debe poner solo una
044209=Clase "{0}" tiene especificación de @Query y @Queries. Usted debe poner solo una
044210=Clase "{0}" tiene especificación de @Join y @Joins. Usted debe poner solo una
044211=Clase "{0}" campo "{1}" tiene anotación "{2}" que no esta procesado aqui. Si sea un annotacion de extension de DataNucleus, lo procesamos mas tarde.

#
# Datastore Connection
#
046000=No es valido usar el metodo "{0}" de una connección obtenida del PersistenceManager.
046001=Connection ya no es disponible

#
# Query Result
#
052600=El resultado del Query ya esta cerrado
052601=Ha encontrado un error leyendo el ResultSet : {0}
052602=No hay más elementos en el resultado del Query
052603=No puede cambiar el ResultSet del Query
052604=No apoyamos esta operación en el resultado de un Query
052605=Cerrar el resultado del Query da un error : {0}
052606=Leyendo los resultados del query "{0}" como la conneccion va a cerrar o cometer

#
#
#
055009=El objeto "{0}" tiene campo "{1}" con una relacion bidireccional, y añadiendo el elemento "{2}" aqi que ponemos el valor del dueño en el elemento.
055010=El objeto "{0}" tiene una relacion 1-N bidireccional "{1}" y vamos a quitar un elemento. Elemento "{2}" va a tener el dueño anulado.

#
# SCO
#
056000=¡El campo "{0}" es una matriz, pero no hay MetaData de <array>!
056001=¡El campo "{0}" es una collección, pero no hay MetaData de <collection>!
056002=¡El campo "{0}" es una mapa, pero no hay MetaData de <map>!
056003=¡El MetaData de la clase de elemento "{0}" del campo de collección "{1}" no esta!
056004=¡El MetaData de la clase de elemento "{0}" del campo de mapa "{1}" no esta!
056005=El estatement del iterador es nulo !!
056006=Solicitud de iterar ha fallado : {0}
056007=Solicitud de tamaño ha fallado : {0}
056008=Solicitud de contener ha fallado : {0}
056009=Solicitud de añadir ha fallado : {0}
056010=Solicitud de cambiar la clave embedded ha fallado : {0}
056011=Solicitud de cambiar el valor embedded ha fallado : {0}
056012=Solicitud de borrar ha fallado : {0}
056013=Solicitud de vaciar ha fallado : {0}
056014=Solicitud de obtener ha fallado : {0}
056015=Solicitud de poner ha fallado : {0}
056016=Solicitud de poner ha fallado : {0}
056017=Solicitud de IndexOf ha fallado : {0}
056018=Solicitud de ContainsKey ha fallado : {0}
056019=Solicitud de ContainsValue ha fallado : {0}
056020=Solicitud de MaxAdapterColumnId ha fallado : {0}
056021=No se puede preguntar sobre una Collection de elementos de segunda clase
056022=No se puede preguntar sobre un Map de valores de segunda clase
056023=GetIndices ha fallado : unos elementos no existen : {0}

056024=El campo "{0}" tiene "mapped-by" como "{1}" pero ese campo "mapped-by" no existe en la clase "{2}".
056025=El campo "{0}" tiene "mapped-by" como "{1}" pero el tipo de ese es incorrecto ({2}). El campo de "mapped-by" tiene que ser del tipo "{3}"
056026=El campo dueño {0} de la clase de elemento {1} tiene un tipo incorrecto "{2}". Debe ser "{3}"
056027=Could not update the foreign key using statement : {0}

#
# SCO Collection
#
056028=El campo de collección "{0}" debe contener el elemento "{1}" pero este elemento esta almacenado como "embedded" en otro campo. ¡Es imposible!. No se puede almacenar un objeto como SCO ("embedded") y como FCO al mismo tiempo

056029=La clase "{0}" tiene campo de collección "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}" campo "{3}"
056030=La clase "{0}" tiene un campo de collección "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}"

056031=El campo "{0}" es una collección con elementos que usan la estrategia de heredar de "subclass-table" y hay más que una tabla basica para los elementos. DataNucleus no apoya esta situación.
056032=La collección tiene element-type "{0}" que es interface y tiene más que una implementación. DataNucleus no apoya el uso de los interfaces cuando haya más que una implementación disponible.

056033=La clase {0} no es de un tipo valido para esta collección (Campo "{1}"). Debe ser "{2}" o algun subclase

056034=La borracion del elemento de FK Collection borra los elementos porque el campo es "dependent"
056035=La borracion del elemento de FK Collection ha borrado los elementos porque las columnas de owner/index no son nulable
056036=La borracion del elemento de FK Collection ha anulado el FK y los ha dejado en la base de datos.

056037=El objeto "{0}" tiene una colleccion "{1}" pero el elemento "{2}" no tiene el dueño puesto. Manejando la relación y poniendo el dueño.
056038=El objeto "{0}" tiene una colleccion "{1}" pero el elemento "{2}" tiene el dueño de "{3}". ¡Usted tiene que corregirlo!

#
# SCO Set
#
056039=Elementos nulos no estan permitidos en persistent sets.
056040=El campo de collección "{0}" del objeto "{1}" debe añadir el elemento "{2}" a la relación M-N pero este elemento ya existe.

#
# SCO List
#
056041=La clase "{0}" tiene un campo de collección "{1}" pero este no tiene un Mapping por el indice de la lista en la tabla de la clase de elementos "{2}". ¿Quizas usted haya declarado el campo como java.util.Collection pero lo haya instanciado como java.util.List sin poner <order> en el MetaData?
056042=La borracion del elemento de Inverse List ha borrado el elemento porque las columnas de owner/index no son nulable
056043=La borracion del elemento de Inverse List ha quitado el elemento de List y lo ha dejado en la base de datos.
056044=El campo "{0}" ha sido instanciado como una lista usando tabla de juntar pero la tabla no tiene una columna de "order". Por favor, ponga un elemento <order> en el MetaData.

#
# SCO Array
#
056045=El campo "{0}" es una collección con elementos que usan la estrategia de heredar de "subclass-table" y hay más que una tabla basica para los elementos. DataNucleus no apoya esta situación.
056046=La clase "{0}" tiene campo de matriz "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}" campo "{3}"
056047=La clase "{0}" tiene un campo de matriz "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}"
056048=La clase "{0}" tiene un campo de matriz "{1}" pero este no tiene un Mapping por el indice de la lista en la tabla de la clase de elementos "{2}"
056049=La matriz tiene element "{0}" que es interface y tiene más que una implementación. DataNucleus no apoya el uso de los interfaces cuando haya más que una implementación disponible.

#
# SCO Map
#
056050=La Mapa "{0}" no tiene ninguna especificacion <key mapped-by=...>. Usted tiene que poner un <key mapped-by=...> porque se almacena la llave en un campo en el valor.
056051=¡La Mapa "{0}" tiene un tipo de llave de "{1}" pero el campo de la llave en el valor es de tipo "{2}"!
056052=¡La clase de valor "{0}" tiene que contener un campo "{1}" que representa la llave, pero no hay ningun campo con este nombre!

056057=La Mapa "{0}" no tiene ninguna especificacion <value mapped-by=...>. Usted tiene que poner un <value mapped-by=...> porque se almacena el valor en un campo en la llave.
056058=¡La Mapa "{0}" tiene un tipo de valor de "{1}" pero el campo de; valor en la llave es de tipo "{2}"!
056059=¡La clase del llave "{0}" tiene que contener un campo "{1}" que representa el valor, pero no hay ningun campo con este nombre!

056053=La clase "{0}" tiene un campo de Mapa "{1}" pero no tiene un Mapping para la clase de los valores "{2}" campo de llave "{3}"
056054=La clase "{0}" tiene un campo de Mapa "{1}" pero no tiene un Mapping para la clase de las llaves "{2}" campo de valor "{3}"
056055=The owner field {0} of value class {1} has an incorrect type "{2}". Should be "{3}"
056056=¡La clase "{0}" tiene un campo de Mapa "{1}" pero no hay ningun Mapping en la tabla de la clase de valores "{2}" para llegar al dueño!

056060=No se puede escribir la llave de otro Persistence Manager
056061=No se puede escribir valor de otro Persistence Manager
056062=Llaves nulas no estan permitidas en persistent maps.
056063=Valores nulos no estan permitidos en persistent maps.
056064=La clase {0} no es de un tipo valido para una llave de este Map. Debe ser {1}
056065=La clase {0} no es de un tipo valido para un valor de este Map. Debe ser {1}
056066=El Mapa "{0}" tiene value-type "{1}" que es interface. DataNucleus no apoya totalmente un value-type asi. Por favor cambialo por una clase.
056067=El campo "{0}" tiene un "mapped-by" con el campo "{1}" pero este campo de "mapped-by" no existe en la clase "{2}".
056068=El campo "{0}" tiene un "mapped-by" con el campo "{1}" pero el tipo esta incorrecta ({2}). El campo de "mapped-by" debe ser de tipo "{3}"

056069=¡El MetaData de la clase de la llave "{0}" del campo de la mapa "{1}" no esta!
056070=¡El MetaData de la clase del valor "{0}" del campo de la mapa "{1}" no esta!

056071=El campo "{0}" es una mapa de ForeignKey. No hay ningun key/value "mapped-by". Usted tiene que poner <key mapped-by="..."> para usar una relación de mapa de ForeignKey.
056072=El campo "{0}" es una mapa de ForeignKey donde se almacena la llave en el valor, pero el valor no es persistable (es "{1}"). Usted tiene que usar un valor de persistable para usar este tipo de relación
056072=El campo "{0}" es una mapa de ForeignKey donde se almacena el valor en la llave, pero la llave no es persistable (es "{1}"). Usted tiene que usar una llave de persistable para usar este tipo de relación
056074=El campo "{0}" es una mapa de ForeignKey donde el valor se almacena en la llave, pero DataNucleus no apoya esta relación

056075=El campo "{0}" es una colleccion "{1}" de elementos del tipo "{2}" pero no hay ningun tipo que se puede persistir alla.


057023=La clase "{0}" no tiene su propia tabla y no hay subclases con tablas tampoco. No es posible crear el esquema!

#
# SQL
#
059000=No apoyamos borración por Query de SQL/DataNucleusSQL.
059001=Tiene un Query de SQL que esta vacia. Es invalido
059002=El estatement de SQL ("{0}") no empieza con SELECT. Es invalido
059004=No se puede usar Extent de Candidatos con un Query de SQL.
059005=No se puede usar collecciones de Candidato con un Query de SQL.
059006=No se puede poner el resultado con un Query de SQL.
059007=No se puede poner el serie con un Query de SQL.
059008=No se puede poner un filtro con un Query de SQL.
059009=No se puede usar variables con un Query de SQL.
059010=SQL apoya grouping pero explicitamente como GROUP BY en el texto de SQL.
059011=SQL apoya ordering pero explicitamente como ORDER BY en el texto de SQL.
059012=Query de SQL : "{0}"
059016=No se puede usar parametros con un Query de SQL.
059025=Error con la ejecucion de Query de SQL "{0}".
059026=No se puede usarlos imports con un Query de SQL.
059027=Error con la ejecucion de Query de stored procedure "{0}".
059028=SQL query "{0}" necesita {1} parametros pero no hay ninguno
059030=SQL query "{0}" necesita un parametro con nombre "{1}" pero no hay ninguno en el Map
