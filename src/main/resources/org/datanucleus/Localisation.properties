################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contributors:
# 2007 Xuan Baldauf - Make error message "023011" a little bit more verbose
#    ...
#
# Resources for org.datanucleus package
################################################################################
#
# ClassLoader
#
001000=Class "{0}" was not found in the CLASSPATH. Please check your specification and your CLASSPATH.
001001=Persistence process has been specified to use a ClassLoaderResolver of name "{0}" yet this has not been found by the DataNucleus plugin mechanism. Please check your CLASSPATH and plugin specification.
001002=ClassLoaderResolver specified to use class "{0}" yet this class is not found! Please check your CLASSPATH and plugin specification.
001003=ClassLoaderResolver for class "{0}" gave error on creation : {1}
001004=Class "{0}" was not found in the CLASSPATH [Class resolver called from {1} (line={2})]
001005=Class "{0}" was not found in the CLASSPATH when trying to resolve classes
001006=Class "{0}" was not present in the CLASSPATH. You need to have "{1}" in the CLASSPATH!

#
# DatastoreIdentity
#
002001=Persistence process has been specified to use datastore-identity of name "{0}" yet this has not been found by the DataNucleus plugin mechanism. Please check your CLASSPATH and plugin specification.
002002=datastore-identity "{0}" specified to use class "{1}" yet this class is not found! Please check your CLASSPATH and plugin specification.
002003=Invalid datastore identity string value : {0}
002004=Identity "{0}" is assigned to class "{1}", but it's not the correct object-id type for this class.

#
# L1 Cache
#
003001=Level 1 Cache "{0}" is not registered. Please check your CLASSPATH and specification.
003002=Level 1 Cache "{0}" is registered to use class "{1}" yet this is not found. Please check your CLASSPATH and plugin specification.
003003=Level 1 Cache of type "{0}" initialised
003004=Object with id "{0}" added to Level 1 cache (loadedFlags="{1}")
003005=Object with id "{0}" replaced in Level 1 cache (loadedFlags="{1}")
003006=Attempt to add null object to Level 1 cache. Rejected.
003007=Object with id "{0}" not found in Level 1 cache
003008=Object with id "{0}" taken from Level 1 cache (loadedFlags="{1}")
003009=Object with id "{0}" removed from Level 1 cache

003011=Level 1 Cache cleared
003012=Object with id "{0}" being changed to be referenced by id="{1}" in Level 1 cache

#
# L2 Cache
#
004000=Level 2 Cache "{0}" is not registered. Please check your CLASSPATH and specification.
004001=Level 2 Cache "{0}" is registered to use class "{1}" yet either this is not found or it threw an exception upon initialisation. Please check your CLASSPATH and plugin specification.
004002=Level 2 Cache of type "{0}" initialised
004003=Object with id "{0}" added to Level 2 cache (fields="{1}", version="{2}")
004004=Attempt to add null object to Level 2 cache. Rejected.
004005=Object with id "{0}" not found in Level 2 cache
004006=Object with id "{0}" taken from Level 2 cache (fields="{1}", version="{2}") - represented as "{3}"
004007=Object with id "{0}" removed from Level 2 cache
004009=Level 2 Cache cleared
004011=Attempt to put a null object into the cache.
004014=Object with id "{0}" removed from Level 2 cache since was updated yet object has been GCed
004015=Object with id "{0}" updated in Level 2 cache (fields="{1}", version="{2}") - fields updated="{3}"
004016=Object with id "{0}" removed from Level 2 cache

#
# Enhancer
#
005000=DataNucleus Enhancer (version {0}) for API "{1}"
005001=DataNucleus Enhancer : Classpath
005002=>>  {0}
005003=Input file "{0}" doesnt exist!
005004=DataNucleus Enhancer completed with success for {0} classes. Timings : input={1} ms, enhance={2} ms, total={3} ms. Consult the log for full details
005005=DataNucleus Enhancer completed with success for {0} classes.
005006=DataNucleus Enhancer completed with an error. Please review the enhancer log (at DEBUG level) for full details. Some classes may have been enhanced but some caused errors
005007=DataNucleus Enhancer completed and no classes were enhanced. Consult the log for full details

005008=No "persistence.xml" files were found in the CLASSPATH yet you specified as input the name ("{0}") of a "persistence-unit" to enhance. You must have a valid "persistence.xml" file in the CLASSPATH in a valid location to use this option.
005009=No "persistence-unit" of name "{0}" was found in the CLASSPATH. Please check the "persistence.xml" files available

005010=Enhance of class "{0}" starting ...
005011=Enhance of class "{0}" completed

005012=Validation of enhancement of class "{0}" starting ...
005013=Validation of enhancement of class "{0}" completed

005014=Class "{0}" is already enhanced.

005015=Writing class file "{0}" with enhanced definition
005016=Class "{0}" needs a primary-key class generating, of name {1}
005017=Writing primary-key class file "{0}"
005018=An error was encountered whilst enhancing class "{0}" : {1}

005019=Adding method "{0}"
005020=Adding constructor "{0}"
005021=Adding field "{0}"
005022=Adding interface: {0}

005023=Enhancing original method {0} changing field "{1}" for call to "{2}"
005024=Enhancing original method {0} : omitting enhance of {1} of field "{2}"

005025=You have just attempted to access field "{0}" yet this field was not detached when you detached the object. Either dont access this field, or detach it when detaching the object.
005026=You have just attempted to access property "{0}" yet this property was not detached when you detached the object. Either dont access this property, or detach it when detaching the object.

005027=Class "{0}" doesnt implement the interface "{1}" but is required
005028=Class "{0}" doesnt have field "{1}" but is required
005029=Class "{0}" has field "{1}" but has incorrect access!
005030=Class "{0}" has field "{1}" but has incorrect type "{2}" (should be "{3}")
005031=Class "{0}" doesnt have method "{1}" but is required
005032=Class "{0}" has method "{1}" but has incorrect access!

005033=Enhancing original method "{0}" to call "dnPreSerialize"

005034=No enhanced bytes available for class "{0}"
005035=No primary-key class bytes available for class "{0}"
005036=ENHANCED (Persistable) : {0}
005037=ENHANCED (Persistence-Aware) : {0}
005038=NOT ENHANCED (Non-Persistent) : {0}
005039=ERROR (Persistable) : {0}
005040=ERROR (Persistence-Aware) : {0}
005041=ERROR (Non-Persistent) : {0}

#
# FetchPlan
#
006000=Field "{0}" declared in the fetch-group "{1}" was not found in the class "{2}
006001=Fetch-group "{0}" nested in the fetch-group "{1}" was not found in class "{2}"
006002=Maximum FetchDepth cannot be given the value {0}. You must specify either -1 (no limit on fetching) or a positive integer.
006003=Detachment roots cannot be changed once set until commit is reached.
006004=Attempt to add the field "{0}" to a fetch group for the class "{1}", but the field doesnt exist in that class!

#
# Reachability
#
007000=Object with id "{0}" and lifecycle state "{1}" added to the list of reachables on commit.
007001=Performing reachability algorithm on object with id "{0}"
007002=Performing reachability on multi-valued container with relation field "{0}"

007004=Performing reachability on single-valued relation field "{0}"
007005=Could not find StateManager for PC object "{0}" at field "{1}" - ignoring for reachability
007006=Field "{0}" has been specified to not use "cascade-persist". Not persisting this field.
007007=Object with id "{0}" field "{1}" is being persisted for "cascade-persist".
007008=Object with id "{0}" field "{1}" has been specified to not use "cascade-update". Not updating this field.
007009=Object with id "{0}" field "{1}" is being updated for "cascade-update".

#
# NucleusContext
#
008000=DataNucleus Context : Version "{0}" with JRE "{1}" on "{2}"
008003=There is no available API adapter "{0}". Using existing adapter.
008004=There is no available StoreManager of type "{0}". Make sure that you have put the relevant DataNucleus 'store' plugin in your CLASSPATH and if defining a connection via JNDI or DataSource you also need to provide persistence property "datanucleus.storeManagerType"
008005=No available StoreManager found for the datastore URL key "{0}". Please make sure you have all relevant plugins in the CLASSPATH (e.g datanucleus-rdbms?, datanucleus-db4o?), and consider setting the persistence property "datanucleus.storeManagerType" to the type of store you are using e.g rdbms, db4o

008009=The MetaDataManager associated with the API "{0}" is not registered. Please check that you have the relevant plugin in your CLASSPATH.
008010=Error creating the MetaDataManager for API "{0}" : {1}
008011=Property "{0}" specified yet cannot be used since the datastore schema is ReadOnly/Fixed
008012=Property "{0}" specified with value "{1}" but this value is invalid. Please check the documentation for valid values
008013=The properties file "{0}" has already been loaded. Ignoring the newly specified properties file  "{1}"
008014=Could not load property file "{0}"
008015=Property {0} unknown - will be ignored
008016=GenerateSchema : could not run schema generation step since this datastore ("{0}") doesn't support schema operations
008017=Compiling NamedQuery {0} : "{1}"

#
# Connections
#
009000=The Connection was acquired by the developer and must be closed before using the persistence API.
009001=Connection factory ({0}) not supported - must be a javax.sql.DataSource
009002=Connection Factory "{0}" not found
009003=A database connection is already in use for this manager - perhaps a Query is still running ? The JDO spec (12.6) states that a Persistence Manager can have one datastore connection open at any one time. As a result if you want to perform multiple operations you should use mutliple PersistenceManagers

009010=Failure to open a connection for datasource "{0}" - check your datasource specification and/or driver
009011=ManagedConnection OPENED : "{0}" on resource "{1}"
009012=ManagedConnection OPENED : "{0}" on resource "{1}" with isolation level "{2}" and auto-commit={3}
009013=ManagedConnection CLOSED : "{0}"
009014=ManagedConnection is already closed : "{0}"
009015=ManagedConnection COMMITTING : "{0}"
009016=ManagedConnection ROLLING BACK : "{0}"
009020=ManagedConnection FAILED TO COMMIT : "{0}" for transaction "{1}" with onePhase="{2}"
009022=ManagedConnection FAILED TO ROLLBACK : "{0}" for transaction "{1}"

#
# ExecutionContext
#
010000=ExecutionContext OPENED "{0}" for datastore "{1}" with txn="{2}"
010001=ExecutionContext CLOSED "{0}"
010002=ExecutionContext has been closed
010003=ExecutionContext.internalFlush() START : using ordered flush - {0} enlisted objects
010004=ExecutionContext.internalFlush() END
010005=Attempt to access HOLLOW nondurable object via getObjectById!
010006=No nondurable object with this id accessible via the cache - maybe for a different manager?
010007=Object with id "{0}" is managed by a different persistence manager
010008=Object is not detached. The operation requires a detached object.
010009=Detaching object from persistence : "{0}" (depth={1})
010010=Detaching copy of object "{0}" (depth={1}) as "{2}" with detached-fields {3} and fields-to-load={4}
010011=DetachOnClose : START - Detaching all current objects ...
010012=DetachOnClose : END
010013=Unable to detach object "{0}" (id="{1}") on commit since it no longer exists in the datastore. Maybe you have datastore constraints that have deleted it
010014=detachCopy cannot be called outside of a transaction when there are transient instances reachable.
010015=Making object persistent : "{0}"
010016=(Re)attaching object with id "{0}" to persistence
010017=Attempt to attach object with id "{0}" to persistence yet another persistent object with this identity already exists enlisted in this transaction
010018=(Re)attaching object to persistence : "{0}" - attaching to be "{1}"
010019=Deleting object from persistence : "{0}"
010020=Transient instances cant be deleted.
010021=Transient-Transactional instances cant be deleted. Object id = {0}
010022=Making object transient : "{0}"

010024=Transient dirty instances can't change to the non transactional state.
010025=Cant call makeNontransactional on Transient non transactional instances
010026=No such object for id "{0}"
010027=Failed to find the object of with id "{0}"
010028=Unable to create Object Identity for class when class is null!
010029=Unable to create Object Identity for class "{0}" since key is of an unsupported type ({1})
010030=Error whilst creating new objectId instance of type "{0}" for abstract class "{1}"
010031=Some instances failed to flush successfully due to optimistic verification problems.
010032=Persistence-By-Reachability (commit) : START
010033=Object with id "{0}" was reachable when a makePersistent() was called on another object but is no longer reachable (at commit). The object will be removed from the datastore.
010034=Persistence-By-Reachability (commit) : END
010035=Cannot perform operation since ImplementationCreator doesnt exist in the CLASSPATH (put datanucleus-core.jar in the CLASSPATH).
010036=One or more instances could not be evicted
010037=One or more instances could not be refreshed
010038=One or more instances could not be retrieved
010039=One or more instances could not be made persistent
010040=One or more instances could not be deleted
010041=One or more instances could not be made transient
010042=One or more instances could not be made transactional
010043=One or more instances could not be made non-transactional
010044=Unable to find the object with a null id!
010045=Unable to find object with id "{0}" of type "{1}" since this is abstract and you requested no validation
010046=ExecutionContext.internalFlush() START : using optimised flush - {0} to delete, {1} to insert and {2} to update
010047=Object "{0}" was detached before its changes could be flushed. Changes will not reach the datastore. This is likely the result of a JPA detach() call before flush(), which is a stupid thing to do anyway, but it was your choice.

010048=Object "{0}" (id="{1}") passed to '{2}' is not managed by a StateManager! The object needs to be managed.

010050=Attempt to start optimistic transaction yet StoreManager for this datastore doesn't support optimistic locking! Set "datanucleus.Optimistic" to false.

010051=Attempt to find persistable object with class "{0}" and key "{1}"!
010052=Attempt to find object of type "{0}" yet no metadata exists for that class, hence not an available persistable type
010053=Attempt to find persistable object with class "{0}" and fieldName(s)="{1}" and value(s)="{2}"!


#
# ImplementationCreator
#
011000=Instance implements persistable loaded by "{0}" but target persistable has classloader "{1}".
011001=A new instance of "{0}" was created, but it is not assignable to PersistenceCapble. Perhaps a classloading problem. "{1}" The instance implements "{2}"
011002=Abstract class "{0}" has abstract method "{1}" but this is not defined as a persistent property in MetaData
011003=Interface "{0}" has method "{1}" but this is not defined as a persistent property in MetaData

#
# Managed Relationships
#
013000=Management of relations : START
013001=Management of relations : END
013002=Management of relations : Object "{0}" field "{1}" was changed to "{2}" but field "{3}" of that object was changed to "{4}"! You can disable this check using "datanucleus.manageRelationshipsChecks"
013003=Management of relations : Object "{0}" field "{1}" was changed to "{2}" but field "{3}" of that object was nulled! You can disable this check using "datanucleus.manageRelationshipsChecks"
013004=Management of relations : Object "{0}" has bidirectional field "{1}" currently set to "{2}" but this is now to be related to "{3}" so nulling this field.
013005=Management of relations : Object "{0}" has bidirectional field "{1}" and object "{2}" has just been set to this object, so updating this objects link across to that object.
013006=Management of relations : Object "{0}" has bidirectional field "{1}" and was related to field "{2}" of object "{3}" but now has been changed. Removing it from the container.
013007=Management of relations : Object "{0}" has a bidirectional field "{1}" and is now related to field "{2}" of object "{3}" but isnt in the container. Adding it.
013008=Management of relations : Object "{0}" has a bidirectional field "{1}" and the object "{2}" was added to this field, but it is in deleted state! You can disable this check using "datanucleus.manageRelationshipsChecks"
013009=Management of relations : Object "{0}" has a bidirectional field "{1}" and the object "{2}" was added to this field, but this field has had its owner set to "{3}"! You can disable this check using "datanucleus.manageRelationshipsChecks"
013010=Management of relations : Object "{0}" has a bidirectional field "{1}" and the object "{2}" was removed from this field, but this field has had its owner set to this one! You can disable this check using "datanucleus.manageRelationshipsChecks"

#
# SchemaTool
#
014000=DataNucleus SchemaTool : Creation of the schema for classes
014001=DataNucleus SchemaTool : Deletion of the schema for classes
014002=DataNucleus SchemaTool : Validation of the schema for classes
014003=DataNucleus SchemaTool : Database information
014004=DataNucleus SchemaTool : Schema information
014005=DataNucleus SchemaTool : Classpath
014006=>>  {0}
014007=No valid input (either a set of metadata/class files, or the name of a persistence-unit) was specified!
014008=An error was encountered creating a PersistenceManagerFactory : {0} - please consult the log for more information.
014009=DataNucleus SchemaTool : Input Files
014010=>>  {0}
014011=Reading {0} input (metadata/class) files ...
014012=Completed read of {0} input (metadata/class) files
014013=Error processing class file ("{0}"), converting to a URL. Please check your specification and CLASSPATH
014014=An error was encountered reading the specified input files. Please consult the log for details. The following may help : {0}
014015=DataNucleus SchemaTool : Handling schema for persistence-unit "{0}"
014016=No "persistence.xml" files were found in the CLASSPATH yet you specified as input the name ("{0}") of a "persistence-unit" to use in SchemaTool. You must have a valid "persistence.xml" file in the CLASSPATH in a valid location to use this option.
014017=No "persistence-unit" of name "{0}" was found in the CLASSPATH. Please check the "persistence.xml" files available
014018=Outputting Schema DDL to "{0}" for all specified classes
014019=Outputting Schema DDL to "{0}" for classes which dont have existing schema
014020=DataNucleus SchemaTool : Persistence Properties
014021=No MetaData was encountered to generate the schema!
014022=>>  {0}={1}

014023=DataNucleus : Help\n>> SchemaTool [options] [mapping-files] [class-files]\nwhere "options" can be\n{0}\n"mapping-files" (and classes specified therein) must be present in the CLASSPATH\n"class-files" must be present in the CLASSPATH
014024=-createSchema <schemaName> : create the actual schema (if supported by the datastore)
014025=-deleteSchema <schemaName> : delete the actual schema (if supported by the datastore)
014026=-create : Create the DB tables for the classes specified by the mapping-files/class-files
014027=-delete : Delete the DB tables for the classes specified by the mapping-files/class-files
014028=-validate : Validate the DB tables for the classes specified by the mapping-files/class-files
014029=-dbinfo : Display the database info (Database version, supported options, datastore types, etc)
014030=-schemainfo : Display the schema info (DDL statements)
014031=-ddlFile <filename> : write all DDL statements to the given file instead of sending them to the DB
014032=-completeDdl : write the DDL for all tables not just the missing ones (when using ddlFile)
014033=-help : Write this message

014034=DataNucleus SchemaTool : Creation of the database (cat={0}, sch={1})
014035=DataNucleus SchemaTool : Deletion of the database (cat={0}, sch={1})

014036=DataNucleus SchemaTool : The mode parameter only accepts values of "create", "delete", "validate", "dbinfo", "schemainfo"
014037=An exception was thrown during the operation of SchemaTool. Please refer to the log for full details. The following may help : {0}
014038=Error parsing JDO meta-data files : {0}
014039=No classes specified !
014040=Class {0} not found ! Please check that the class is in the CLASSPATH.
014041=Database driver/URL not specified !
014042=Error : No JDO MetaData files specified !
014043=DataNucleus SchemaTool completed successfully
014044=-delete-create : Delete the DB tables for the classes specified by the mapping-files/class-files and recreate them
014045=DataNucleus SchemaTool : Deletion+Creation of the schema
014046=Datastore script "{0}" was not a valid script; has to be a filename, or a URL string

#
# Transactions
#
015000=Transaction begun for ExecutionContext {0} (optimistic={1})
015001=Transaction committing for ExecutionContext {0}
015002=Transaction rolling back for ExecutionContext {0}
015003=Transaction begun with connection {0}
015004=Transaction failed to start
015005=Transaction failed to flush
015006=Transaction committing with connection {0}
015007=Transaction failed to commit
015008=Transaction rolling back with connection {0}
015009=Transaction failed to commit

015012=Invalid isolation level : {0}
015013=Connection {0} started for pessimistic transaction
015014=Connection {0} closed for pessimistic transaction
015015=Connection {0} started for optimistic transaction
015016=Connection {0} closed for optimistic transaction
015017=Object with id "{0}" enlisted in transactional cache
015018=Object with id "{0}" enlisted in transactional cache is now enlisted using id="{1}"
015019=Object with id "{0}" was evicted from transactional cache
015020=Transaction has been marked as "rollback-only". Commit cannot be performed in this state.
015021=Couldnt obtain a connection.
015022=Transaction committed in {0} ms
015023=Transaction rolled back in {0} ms
015024=Use of JTA transactions requires use of a managed datasource since it relies on the TransactionManager to commit datastore connections.
015025=We have already synchronised with the JTA transaction, yet another request was raised to do this!
015026=User requested JTA transactions yet an error occurred while obtaining the JTA transaction.
015027=JTA transaction is marked for rollback, probably had a timeout. Any subsequent operation requiring a database connection will fail.
015028=Error while trying to interrogate JTA Transaction's status!
015029=JTA transaction required to synchronise with the JTA transaction manager, yet we could not access the NamingService. Please check your environment.
015030=JTA transaction required to synchronise with JTA transaction manager, yet we couldnt find the TransactionManager (only WebLogic, JBoss supported)
015031=A database transaction has been rolled back, but the following exceptions were thrown while transitioning the state of the JDO objects participating in the transaction.
015032=Transaction is already active.
015033=Transaction is already active.
015034=Transaction is still active. You should always close your transactions correctly using commit() or rollback().
015035=Transaction is not active. You either need to define a transaction around this, or run your PersistenceManagerFactory with 'NontransactionalRead' and 'NontransactionalWrite' set to 'true'
015036=Transaction is commiting or rolling back. This operation is not available at the moment.
015037=A database transaction has been committed, but the following exceptions were thrown while transitioning the state of the JDO objects participating in the transaction.
015038=Operation {0} failed on resource: {1}, error code {2} and transaction {3} : {4}
015039=Running {0} operation on resource: {1}, error code {2} and transaction {3}
015040=Transaction is not active. You need to define a transaction around this
015041=Impossible to perform operation since it either requires an active transaction or 'NontransactionalRead' enabled. You have neither of these.
015042=Impossible to perform operation since it either requires an active transaction or 'NontransactionalWrite' enabled. You have neither of these.
015043=The datastore doesnt support the selected transaction isolation level "{0}"
015044=Exception flushing work in JTA transaction. Mark for rollback. Look at the nested exception for details
015045=Cannot mark transaction for rollback after exception in beforeCompletion. PersistenceManager/EntityManager might be in inconsistent state
015046=Exception during afterCompletion in JTA transaction. PersistenceManager/EntityManager might be in inconsistent state
015047=Received unexpected transaction status "{0}"
015048=Transaction.afterCompletion called on {0} but is already closed. This is likely because you're using a JavaEE container (e.g JBoss) that has closed the EntityManager before calling afterCompletion on the transaction of that EntityManager. The JPA spec is totally inadequate in that it does not define the order of such afterCompletion calls and really should state in BOLD that the EntityManager should only be closed after all JTA afterCompletions have been called; try requesting that of the JPA EG. Any statistics gathering is rendered incorrect as a result.

#
# Types
#
016001=Java type {0} using the support for {1}
016002=Exception thrown in converting "{0}" into object of type "{1}"
016003=Java types support initialising ...
016004=User-defined type mapping class "{0}" was not found. Please check the mapping file class specifications and your CLASSPATH. The class must be in the CLASSPATH.
016005=User-defined SCO wrapper class "{0}" was not found. Please check the mapping file class specifications and your CLASSPATH. The class must be in the CLASSPATH.
016006=Java types support loaded : supported java types={0}
016007=Type converter support initialising ...
016008=Type converter support loaded
016009=Container handler class "{0}" was not found. The class must be in the CLASSPATH.

#
# Sequence
#
017000=The requested sequence "{0}" could not be found. Please make sure that it is specified in a valid Meta-Data file.
017001=The factory class "{0}" for the sequence "{1}" was not found. Please check that it is in the CLASSPATH.
017002=Error when invoking the static method newInstance() on the factory class "{0}" : {1}
017003=The sequence "{0}" has been created, and uses id generator "{1}"
017004=The sequence "{0}" does not have any values allocated. Please call the "allocate(int)" method first to allocate some values.
017005=The sequence "{0}" does not generate numeric values. Please use the "next()" method to access the Object value.
017006=Error while obtaining connection for value generation : {0}
017007=Error while closing connection for value generation : {0}

#
# Exceptions
#
018000=The class "{0}" is not persistable. This means that it either hasn't been enhanced, or that the enhanced version of the file is not in the CLASSPATH (or is hidden by an unenhanced version), or the Meta-Data/annotations for the class are not found.
018001=The class "{0}" is required to be persistable yet no Meta-Data/Annotations can be found for this class. Please check that the Meta-Data/annotations is defined in a valid file location.
018002=The class "{0}" is not persistable. This means that it either hasn't been enhanced, or that the enhanced version of the file is not in the CLASSPATH (or is hidden by an unenhanced version), or the Meta-Data for the class is not found.
018003=The class "{0}" is required to be persistable yet no Meta-Data can be found for this class. Please check that the Meta-Data is defined in a valid file location for JDO.
018004=The class "{0}" is not Detachable. This means that the MetaData for the class did not have the "detachable" attribute set to true.
018005=Some of the specified objects are of classes that are not Detachable. This means that the MetaData for the classes did not have the "detachable" attribute set to true. The nested exceptions contains the details for these objects.
018006=Object of type "{0}" is detached. Detached objects cannot be used with this operation.
018007=Persistent class "{0}" has no extent (defined in the Meta-Data). Please check the specification of the MetaData for this class is you require an Extent.
018008=Field "{0}" contains a persistable object that isnt persistent, but the field doesnt allow cascade-persist!
018009=Field "{0}" does not exist in {1} or is not persistent
018010=Field number {0} does not exist in {1} or is not persistent

#
# Primary Key
#
019000=Class "{0}" has been specified with an object-id class {1} which is an inner class but is not static. The ObjectId class MUST be sttaic if it is defined as an inner class.
019001=Class "{0}" has been specified with an object-id class {1} which is not public. The ObjectId class MUST be public.
019002=Class "{0}" has been specified with an object-id class {1} which is not Serializable. The ObjectId class MUST be Serializable.
019003=Class "{0}" has been specified with the JDO SingleFieldIdentity object-id class, but there are more than 1 primary key field specified for the class. Only one field can be specified as primary key.
019004=Class "{0}" has been specified with an object-id class {1} which doesn't have a default constructor. All objectId classes MUST have a default constructor.
019005=Class "{0}" has been specified with an object-id class {1} which doesn't have a String constructor. All objectId classes MUST have a String constructor.
019006=Class "{0}" has been specified with an object-id class {1} which doesn't override the toString() method. All objectId classes MUST override the toString() method.
019007=Class "{0}" has been specified with an object-id class {1} which doesn't override the hashCode() method. All objectId classes MUST override the hashCode() method and return a value based on the values of all PK fields.
019008=Class "{0}" has been specified with an object-id class {1} which doesn't override the equals() method. All objectId classes MUST override the equals() method and return a value based on the values of all PK fields.
019009=Class "{0}" has been specified with an object-id class {1} which has a field {2} which isn't Serializable. All non static fields of an objectId class must be serializable.
019010=Class "{0}" has been specified with an object-id class {1} which has a field {2} which isn't public. All non static fields of an objectId class must be public.
019011=Class "{0}" has been specified with an object-id class {1} which has a field {2}, but this field was not found in Class {0}.
019012=Class "{0}" has been specified with an object-id class {1} which has a field {2}. The field {0}.{2} has type {3} which is persistence capable. All non static fields of an objectId class must include the names of the primary key fields in the JDO class, and the types of the corresponding fields must be identical.
019013=Class "{0}" has been specified with an object-id class {1} which has a field {2}. The field {1}.{2} has type {3} but should be {4}. All non static fields of an objectId class must include the names of the primary key fields in the JDO class, and the types of the corresponding fields must be identical.
019014=Class "{0}" has been specified with an object-id class {1} which has a field {2}. The field {1}.{2} has type {3} that must be specified in the metadata /jdo/package/class/@objectid-class attribute for type {4}. e.g <class name="{4}" objectid-class="{3}"/>
019015=Class "{0}" has been specified with an object-id class {1} which has {2} fields, whereas the class has been defined with {3} fields in the primary key. The number of fields in the objectidClass and the number in the primary key must concur.
019016=Class "{0}" has invalid primary key class {1}.

#
# Query
#
021000=Incompatible query element type : was {0}, but must be {1} or a subclass
021001=The query returned more than one instance BUT either unique is set to true or only aggregates are to be returned, so should have returned one result maximum
021002=Invalid import declaration : {0}
021003=Invalid package import : {0}
021004=Duplicate class import found for {0}
021005=Class named in imports not found : {0}
021006=Caching the fact that {0} was not found by {1}
021007=Array types are illegal here : {0}
021008=Ambiguous class declaration, could be {0} or {1}
021009=Candidate class "{0}" not found
021010=Class {0} was resolved to be {1}. It wasn't defined fully-qualified so had to be looked up; you can avoid the lookup (and improve performance) by fully-qualifying the class in the query.
021011=Attempt to invoke method "{0}()" on object of type "{1}" - not supported for this datastore
021012={1} Query : Processing the "{0}" clause using in-memory evaluation (clause = "{2}")
021013=Manager that was used to generate the Query is closed!
021014=This query is in an unmodifiable state. It's structure cannot be changed
021015=The Query contains a class-name "{0}" (candidate class, result class, parameter, or variable) yet this cannot be resolved. Please check the name, and the imports for the Query.
021016=Query contains access of "{0}" yet this field/property doesn't exist
021017=Query has no associated Manager
021018=Execution of the query "{0}" was not completed before the timeout of {1}ms
021019=Starting query "{0}" in separate thread with timeout of {1}ms
021020=Query "{0}" has been cancelled
021021=An error has occurred executing the query "{0}"
021022=Starting query "{0}" in separate thread with no timeout
021023=Evaluation of filter for candidate="{0}" gives a match
021024=Evaluation found variable="{0}" not set, and should take values from "{1}"
021025=Evaluation being attempted for variable="{0}" with value of "{1}"
021026=Evaluation has processed all values of variable="{0}" so removing its value
021027=Query has been specified to delete persistent objects, yet ordering has been specified. You cannot specify the ordering on such a deletion query.
021028=Query has been specified to delete persistent objects, yet grouping has been specified. You cannot specify the grouping on such a deletion query.
021029=Query has been specified to delete persistent objects, yet the result has been specified. You cannot specify the result on such a deletion query.
021030=Query has been specified to delete persistent objects, yet the resultClass has been specified. You cannot specify the resultClass on such a deletion query.
021031=Query has been specified to delete persistent objects, yet the result range has been specified. You cannot specify the result range on such a deletion query.
021032=Query has been specified with "unique" and to delete persistent objects, however the query implies the deletion of more than 1 object. You should remove the "unique" specification if you want to delete these objects.

021034=Dont currently support queries of language "{0}" for datastore "{1}"

021038=This implementation of JDOQL doesn't yet support bulk updates
021039=This implementation of JDOQL doesn't yet support bulk deletes
021040=This implementation of JPQL doesn't yet support bulk updates
021041=This implementation of JPQL doesn't yet support bulk deletes
021042=Exception thrown when executing query : {0}
021043=Error encountered when extracting results for query "{0}"
021044={0} Query : Compile (generic) of "{1}"
021045={0} Query : Compile Time (generic) = {1} ms
021046={0} Query : Executing "{1}" ...
021047={0} Query : Error during execution of "{1}" : {2}.
021048=No candidate class provided for {0} query
021049=Unable to find the field "{0}" in the candidate class. It is possible that this field is a field in a subclass, but it is illegal to reference fields directly when they are in a subclass.
021050=Query filter "{0}" doesn't yield a boolean result
021052={0} query contains the identifier "{1}", yet this is a keyword. The query is invalid.
021053=Class "{0}" is used in a cast operation in a query yet could not be found. Please make sure that this class is contained in the CLASSPATH and it's declared in query imports.
021054=The {0} query contains an invalid expression
021055=Query has had some parameter(s) declared ("{0}"), yet also has at least 1 implicit parameter ("{1}"). This is invalid. Parameters must either be all explicit (declared), or all implicit (specified using a : prefix).
021056=Query has been specified with an implicit parameter "{0}" (parameter position {1}) yet there is no parameter value specified for this when the query was executed!
021057=Use of "new" in {0} queries must be followed by a valid class name, yet {1} is not found. Please check the imports for this query.
021058=Use of "new" in {0} queries must be followed by a class name and the constructor arguments, yet isn't in "{1}"
021060=Error binding "{0}" to "{1}" since it was previously bound to "{2}".
021061=Variable "{0}" has not been bound to the query!

021064=The range {0} expression accepts only Literal values. Either define it as parameter or a literal. The current value is {1}.
021065=The range {0} expression expects a number, but it currently is {1}.
021066=Unable to find the class for "{0}". Please check that this class is accessible in the CLASSPATH.
021068=Parameter for query ("{0}") is bound to a different manager than this query!
021069=The ordering has a field expression "{0}" that doesnt appear in the grouping. Any ordering specification has to be present in the grouping when grouping is specified
021070=The result clause has a field expression "{0}" that doesnt appear in the grouping. Any result specification has to be present in the grouping when grouping is specified
021071=The having clause has a field expression "{0}" that doesnt appear in the grouping. Any having specification has to be present in the grouping when grouping is specified
021072=Candidates collection specified for query is null.
021074={0} Query : Execution Time = {1} ms
021075=Not caching the datastore compilation since some parameters are evaluated during the compilation and aren't present in the final datastore-specific query

021079=Query "{0}" of language "{1}" has been run before so reusing existing generic compilation
021080=Query "{0}" of language "{1}" for datastore "{2}" has been run before so reusing existing datastore compilation
021081=Query "{0}" when executed had {1} results. These are being cached.
021082=Query "{0}" was found in the query results cache with {1} results. Using those

021083={0} Query : Compile (datastore) of "{1}"
021084={0} Query : Compile Time (datastore) = {1} ms

021086=JDOQL query has result clause "{0}" but this is invalid (see JDO spec 14.6.10). When specified with grouping should be aggregate, or grouping expression
021087=JDOQL query has ordering clause "{0}" but this is invalid (see JDO spec 14.6.10). When specified with grouping should be aggregate, or grouping expression
021088=JDOQL query has having clause "{0}" but this is invalid (see JDO spec 14.6.10). Should contain only aggregates, or grouping expressions
021089=JDOQL query has result clause using aggregate ("{0}") but this needs 1 argument

# Query : Parameters/Variables
021101=Query has an invalid parameter list "{0}"
021102=Query has an illegal parameter name "{0}"
021103=Query has a duplicate parameter name "{0}"
021104=Query has an invalid variable list "{0}"
021105=Query has an illegal variable name "{0}"
021106=Query has a variable name "{0}" which conflicts with a parameter name
021107=Query has a duplicate variable name "{0}"
021108=Query requires {0} parameters, yet {1} values have been provided.
021109=The parameter {0} expected the argument value of primitive type {1}.
021110=The {0} query requires a parameter "{1}" yet this hasn't been provided.
021111=Query has had some variable(s) declared ("{0}"), yet also has at least 1 implicit variable ("{1}"). This is invalid. Variables must either be all explicit (declared), or all implicit.
021112=Query has been specified with an implicit parameter "{0}" yet there is no parameter value specified for this when the query was executed!
021113=Query has had the value specified for an implicit parameter "{0}" yet this parameter doesnt exist in the query itself!
021114=Query has parameter "{0}" represented as a {1} yet is being compared to a {2}. Parameter values should be consistent with what they are compared with
021115=Query has subquery defined but the variable declaration is null! A subquery has to pass its value across to the main query via a variable
021116=Query has parameter "{0}" supplied at execution yet the query doesnt make use of this parameter
021117=Query has parameter "{0}" defined as "{1}" but is supplied as null!
021119=Query has parameter "{0}" defined yet it has not been supplied to the query execute() method

# Query : Result
021201=The Query will return multiple fields yet the ResultClass has been set to a simple type ({0}). These are inconsistent.
021202=The Query will return a single field but it is not of a consistent type as the ResultClass ({0}) : It is {1}
021203=Query was required to return objects of type "{0}" yet it was impossible to create objects of this type. Check that the result class is valid for the query API.
021204=Query needs to return objects of type "{0}" but it was impossible to set the field "{1}" type "{2}". The field should have either a public set/put method, or be public.
021205=Query needs to return objects of type "{0}" but it was impossible to create a new instance of this type. The result class needs a no-args constructor.
021206=Result Class "{0}" doesnt have a public constructor with args of types {1}
021207=Result Class "{0}" doesnt have a public method "void {1}({2})".
021208=Result Class "{0}" doesnt have a public method "void {1}(Object, Object)".
021209=Result Class "{0}" doesnt have a public field "{1}"
021215=Query has column "{0}" but result class doesn't have an equivalent field - ignoring
021216=Result Class "{0}" will be created using argumented constructor with args of type(s) "{1}"
021217=Result Class "{0}" will be created using default constructor
021218=Result Class "{0}" field "{1}" set using reflection
021219=Result Class "{0}" field "{1}" set using reflection after converting value
021220=Result Class "{0}" field "{1}" set using (public) setter method
021221=Result Class "{0}" field "{1}" set using (public) setter method after converting value
021222=Result Class "{0}" field "{1}" set using (public) put(x,y) method

# Query Cache
021500=Query Cache "{0}" is not registered. Please check your CLASSPATH and specification.
021501=Query Cache "{0}" is registered to use class "{1}" yet this is not found. Please check your CLASSPATH and plugin specification.
021502=Query Cache of type "{0}" initialised

#
# Api Adapter
#
022000=Error : An error occurred trying to instantiate an instance of the API adapter "{0}" (perhaps you dont have the requisite datanucleus-api-XXX jar in the CLASSPATH, or the API jar for the persistence spec you are using?) : {1}
022001=Error : Could not find API definition for name "{0}". Perhaps you dont have the requisite datanucleus-api-XXX jar in the CLASSPATH?

#
# SCO
#
023000=Incompatible type requested for field "{0}" : was {1} but should be {2}
023001=Nulls are not allowed for field "{0}" in object "{1}"
023002=SCO Collection/Map is not queryable since it is not currently owned by any first-class object.
023003=Created SCO wrapper of type {0} for object "{1}" field "{2}" with {3} entries, using options="{4}"
023004=Object "{0}" field "{1}" is replaced by a SCO wrapper of type "{2}" {3}
023005=Object "{0}" field "{1}" flushing changes to the datastore
023006=Object "{0}" field "{1}" loading contents to SCO wrapper from the datastore
023007=Object "{0}" field "{1}" is having its SCO wrapper initialised with a container with {2} values
023008=Object "{0}" field "{1}" is having its SCO wrapper updated with a container with {2} values
023009=Can't write object "{0}" since it is managed by a different persistence manager
023011=Class {0} (declared type of field {2} referencing {1}) is not supported as a Second-Class object
023012=The field "{0}" has been specified to use a comparator of type "{1}" yet this class was not found in the CLASSPATH. Please check the name of the comparator class specified in the MetaData.
023013=Execution of method "{0}" on field "{1}" caused an error : {2}

#
# Plugin
#
024000=File {0} doesn't exist. Check your path or classpath.
024001=Error reading plug-in file {0} : {1}
024002=Extension Point "{0}" not registered, but plugin "{1}" defined in {2} refers to it.
024003=Loading extension points and extensions from plug-in file {0}.
024005=Plugin Registry "{0}" not found. Falling back to DataNucleus registry

024007=Error registering Bundle since URL to manifest.mf is null
024008=Error reading manifest file "{0}"
024009=Plugin (Bundle) "{0}" is already registered. Ensure you dont have multiple JAR versions of the same plugin in the classpath. The URL "{1}" is already registered, and you are trying to register an identical plugin located at URL "{2}."
024010=Error creating URL for plugin MANIFEST file "{0}"
024011=Error reading MANIFEST.MF for "{0}"
024012=Could not find MANIFEST.MF file for plugin file "{0}" so ignoring it
024013=Bundle "{0}" has an optional dependency to "{1}" but it cannot be resolved
024014=Bundle "{0}" requires "{1}" but it cannot be resolved.
024015=Bundle "{0}" requires "{1}" version "{2}" but the resolved bundle has version "{3}" which is outside the expected range.
024016=Error creating DocumentBuilder to parse XML file : {0}

#
# CallbackHandler
#
025000=Error : An error occurred trying to instantiate an instance of the CallbackHandler "{0}" : {1}
025001=An exception was thrown from the user callback "{0}".

#
# StateManager
#
026000=Insufficent access granted to org.datanucleus.*
026001=Disconnecting clone {0} from {1}
026002=No such field {0} in class {1}
026003=Attempted to replace the StateManager with a different one
026004=Attempted to clear the StateManager then disconnect
026005=Clearing StateManager for {0}
026006=This StateManager method should never be called. Please report this to developers with a way of reproducing it
026007=Cannot share owned second-class objects, object owned by field {0} of object {1}
026008=deletePersistent() called recursively
026009=flush() called recursively
026010=Object is marked as dirty yet no fields are marked dirty
026011=Disconnecting object with id "{0}" from {1}
026012=Specified class {0} is not persistable
026013=No such object (identity="{0}")
026014=Failed to find the object of class "{0}" with id "{1}"
026015=Class {0} not found ! Please check that the class is in the CLASSPATH.
026016=The primary-key field {0} is null.
026017=An object of class "{0}" uses SingleFieldIdentity using the field "{1}" yet this field has not had its value set! Either set the field manually, or set a value-strategy for that field.
026018=Class "{0}" has not been registered. Please check that it is enhanced.
026019=Cannot create new instance of class "{0}". If this is an abstract class, make sure you don't have a row for that class in the database without a corresponding row in any concrete subclass table.
026020=Field "{0}" has been specified with a value-strategy of "{1}" but the field is of an invalid type.
026021=Field "{0}" of object "{1}" has been registered for updating when its value PC object ("{2}") is inserted into the datastore.
026022=Field "{0}" of object "{1}" is being updated now that its value PC object ("{2}") is inserted in the datastore.
026023=Object of type "{0}" and identity "{1}" cannot be detached since it is already in deleted state!
026024=Object of type "{0}" and identity "{1}" cannot be detached since it is already detached!
026025=Object of type "{0}" and identity "{1}" was not detached correctly. Please consult the log for any possible information.
026026=Object "{0}" is being deleted since the field ({1}) where it was the value has just been nulled and the field is delete-dependent.
026027=An illegal "{0}" transition was attempted from the "{1}" state, sm = "{2}"
026028=Object "{0}" has been marked for persistence but its actual persistence to the datastore will be delayed due to use of optimistic transactions or "datanucleus.flush.mode" setting
026029=Object with id "{0}" is having the value in field "{1}" replaced by a SCO wrapper
026030=Object with id "{0}" is having the SCO wrapper in field "{1}" replaced by the unwrapped value
026031=Object with id "{0}" is to be detached (using DetachAllOnCommit?) but is not detachable, so being made transient
026032=Object with id "{0}" has a non-detached value in field {1} that is outside the range of the FetchPlan. Unloading it.
026033=Object with id "{0}" is having the following fields in Level 2 cache object updated : {1}
026034=Object with id "{0}" is loading the following fields from the Level 2 cache object : {1}

026035=Attaching object with id "{0}" fields="{1}"
026036=Unexpected exception during attach of object with id "{0}" : {1}

026037=Storing FK value for member "{0}" of "{1}" to STORED-VALUE-CACHE
026038=Setting member "{0}" of "{1}" from STORED-VALUE-CACHE

#
# LifeCycle states
#
027000=Cant read fields outside of transactions. You may want to set 'NontransactionalRead=true'.
027001=Cant write fields outside of transactions. You may want to set 'NontransactionalWrite=true'.
027002=Cant read fields outside of transactions. You may want to set 'NontransactionalRead=true'.
027003=Cannot make object non-transactional since object is new, deleted and not yet committed
027004=Cannot make object transient since object is new, deleted and not yet committed
027005=Cannot read fields from a deleted object
027006=Cannot write fields to a deleted object
027007=Cannot make object non-transactional since object has been deleted
027008=Cannot make object transient since object has been deleted
027009=Cannot read fields from a deleted object
027010=Cannot write fields to a deleted object
027011=Cannot make object non-transactional since object is dirty
027012=Cannot make object transient since object is dirty
027013=Cannot make object non-transactional since object is new and not yet committed
027014=Cannot make object transient since object is new and not yet committed
027015=Field not copied to the detached instance. Add to your FetchPlan this field and detach the object.
027016=Object with id "{0}" has a lifecycle change : "{1}"->"{2}"

#
# XML Parser
#
028000=XML Entity Public="{0}" System="{1}" : using local source "{2}"
028001=XML Entity Public="{0}" System="{1}
028002=resolveEntity({0}, {1}) could not be found
028003=resolveEntity({0}, {1}) failed!

#
# SingleFieldIdentity
#
029000=Impossible to construct a SingleFieldIdentity of type "{0}" since the class passed is null.
029001=The id type passed to construct a SingleFieldIdentity for class "{0}" is null.
029002=The id type ("{0}") passed to construct a SingleFieldIdentity for class "{1}" is invalid.
029003=The key value passed to construct a SingleFieldIdentity of type "{0}" for class "{1}" is null.
029004=The key value passed to construct a SingleFieldIdentity of type "{0}" for class "{1}" is of an incorrect type ("{2}") - should be "{3}".

#
# Utils
#
030003=Bad timestamp format: "{0}" - must be yyyy-mm-dd hh:mm:ss.fffffffff
030004=Missing constructor in class {0}, parameters {1}
030005=Failed attempting to access class {0}
030006=Failed instantiating a new object of type {0}
030007=Unexpected exception thrown by constructor for {0}, {1}

#
# RDBMS Views/Macros
#
031000=Unmatched braces for identifier macro: {0}
031001=Unmatched question marks for parameter macro: {0}
031002=Cannot parse identifier macro: {0}
031003=A circular dependency exists between views : 

#
# Store Manager
#
032001=Managing Persistence of {0}
032002=Unmanaging Persistence of all classes
032003=Managing Persistence of {0} since it was managed previously

032004=Insert/Update/Delete of object "{0}" for read-only datastore! You should make this datastore read-write if you want to modify objects
032005=Insert/Update/Delete of object "{0}" into read-only datastore will be ignored.
032006=Insert/Update/Delete of object "{0}" for read-only class! You should make this class read-write if you want to modify objects
032007=Insert/Update/Delete of object "{0}" for read-only class will be ignored.

032010=Delete dependent of object "{0}" from read-only datastore! You should make this datastore read-write if you want to delete objects
032011=Delete dependent of object "{0}" from read-only datastore will be ignored.

032012=The class "{0}" is tagged as "embedded-only" so does not have its own datastore table.
032013=The class "{0}" is using subclass-table strategy and no subclass/superclass has defined a table.
032014=The class "{0}" is using {1} strategy and no table were found to persist the object.
032015=Attempt to retrieve table name for null class !

032016=Object with id "{0}" has been changed in the datastore since your last read. Datastore record has version "{1}" whereas your transaction is using version "{2}"
032017=Class "{0}" has been defined with optimistic version strategy of "{1}" yet this is not supported by DataNucleus currently. Please consult the documentation for supported optimistic strategy values

032018=Registered transactional connection factory under name "{0}"
032019=Registered nontransactional connection factory under name "{0}"

032020=StoreManager : "{0}" using the URL "{1}" - datastore-mode={2}

#
# Extent
#
033000=Extent cannot be created for class because the class name hasn't been specified.
033001=Extent cannot be created for class "{0}" because no Meta-Data was found for this class.
033002=Extent of {0} include_subclasses={1}
033003=Query over Extent will never return results without including subclasses : extent= {0}, class={1}

#
# Auto Starter
#
034000=Error starting up DataNucleus : a class "{0}" was listed as being persisted previously in this datastore, yet the class wasn't found. Perhaps it is used by a different DataNucleus-enabled application in this datastore, or you have changed your class names.
034001=Deleting class {0} from list of persistence-managed classes
034002=Unknown Error during auto starter execution. : {0}
034003=Illegal state of AutoStart, disabling it. To enable it, resolve earlier errors.
034004=Error starting up DataNucleus : a class "{0}" was listed as being persisted previously for this datastore yet no MetaData was found for this class.
034005=AutoStart Mechanism "{0}" starting
034006=AutoStart Mechanism "{0}" completed

034100=Class based auto-start. You provide a list of classes to load up when initialising the PMF.

034150=MetaData based auto-start. You provide a list of metadata files to load up when initialising the PMF.

034200=XML file based auto-start. Stores definition in an XML file
034201=XML AutoStarter file {0} doesn't exist. Creating it ...
034202=Error reading XML AutoStarter file {0} : {1}
034203=Error writing XML AutoStarter file {0} : {1}
034204=resolveEntity({0}, {1})

#
# Store Data
#
035002=Class : {0}
035003=Field : {0}
035004=Class : {0} [Table : {1}, InheritanceStrategy : {2}]
035005=Field : {0} [Table : {1}]

#
# JDOQL Expressions
#
037003=Query has been specified to compare with an object "{0}" which has no JDO identity - maybe the object is transient or embedded. This will always return no instances.

037005=Query has been specified to refer to the field "{0}" yet this field relates to a class using "subclass-table" inheritance strategy, and has no possible subclasses with their own tables. A JDOQL query cannot be formed in this situation.
037006=Query has been specified to refer to the field "{0}" yet this field relates to a class using "subclass-table" inheritance strategy. DataNucleus only currently supports a 1-1 relation to a "subclass-table" class when there is only one subclass possible, but here there are more than 1! DataNucleus will use "{1}"

037013=JDOQL query has been specified with a new object expression for a constructor for class "{0}" that doesnt exist! Please correct the query.

037015=Error occurred when creating new instance of "{0}" : {1}
037016=Query has been specified with instanceof for "{0}" which is not a known class name
037017=Query has been specified with cast for "{0}" which is not a known class name

#
# Value Generators
#
040000=Unable to create generator for ids of type "{0}" : {1}
040001=Creating ValueGenerator instance of "{0}" for "{1}"

040002=Repository of unique IDs is not valid.
040003=Error encountered allocating block of IDs : {0}
040004=Reserved a block of {0} values
040005=Creating Repository for IDs in the datastore
040006=Invalid value for key-cache-size = {0}
040007=Invalid value for sequence = {0}
040008=Error encountered allocating IDs : {0}
040009=The generator "{0}" does not generate numeric values. Please use the "next()" method to access the Object value.

040010=Could not create new "sequence" {0} since autoCreate flags do not allow it.
040011=Could not create "increment"/"table" value-generation container {0} since autoCreate flags do not allow it. 

040012=Generated value for field "{0}" using strategy="{1}" (Generator="{2}") : value={3}
040013=Invalid Id generated for field {0}, id : {1}
040014=Field "{0}" has been specified to use a TableGenerator but none was found with name "{1}"
040015=Field "{0}" has been specified to use a SequenceGenerator but none was found with name "{1}"

#
# JDOQL
#
042010=JDOQL Single-String with "{0}"
042011=Query contains a JDOQL keyword ("{0}") that is out of order. Keywords can only be used in a defined order.
042012=JDOQL Single-String query should always start with SELECT
042013=JDOQL Single-String query has been specified with keyword "{0}" but with illegal following value "{1}"
042014=JDOQL Single-String query has been specified with keyword "{0}" but has no value specified. Should have "{1}" specified after "{0}".
042015=JDOQL Single-String expects the keyword "{0}" after the keyword "{1}"
042016=JDOQL Single-String query has been specified with a class "{0}" which could not be found. Please make sure that this class is contained in the CLASSPATH
042017=JDOQL Single-String query has a subquery clause without a closing parenthesis.

#
# JPQL
#
043000=JPQL Single-String with "{0}"
043001=JPQL Query contains a keyword ("{0}") that is out of order. Keywords can only be used in a defined order.
043002=JPQL Query should always start with SELECT/UPDATE/DELETE/INSERT
043003=JPQL Query has been specified with keyword "{0}" but with illegal following value "{1}"
043004=JPQL Query has been specified with keyword "{0}" but has no value specified. Should have "{1}" specified after "{0}".
043005=JPQL Query expects the keyword "{0}" after the keyword "{1}"
043006=JPQL Query has been specified with a class "{0}" which could not be found. Please make sure that this class is contained in the CLASSPATH
043007=JPQL UPDATE/DELETE query cannot have GROUP BY clause
043008=JPQL UPDATE/DELETE query cannot have HAVING clause
043009=JPQL UPDATE/DELETE query cannot have ORDER BY clause
043010=JPQL UPDATE query has no update clause! Query should be like "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"
043011=JPQL UPDATE query has update clause but no SET component. Query should be like "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"

#
# MetaData
#
044001=Class "{0}" field "{1}" : metadata has attribute "{2}" defined with value "{3}" yet only accepts "{4}"
044002=MetaData extension "{0}" has valid values of "{1}" but is set to "{2}"!
044003=Class "{0}" field "{1}" : Has a Collection yet no element type is provided in MetaData nor is inferrable using generics, so using Object
044004=Class "{0}" field "{1}" : Has a Map yet no key/value types are provided in MetaData nor is inferrable using generics, so using Object

044005=MetaData Management : Loading Metadata for metadata files "{0}" ...
044006=MetaData Management : Loading Metadata for classes "{0}" ...
044007=MetaData Management : Loading Metadata for persistence-unit "{0}" ...
044008=MetaData Management : Loading Metadata from user ...
044009=MetaData Management : Load of Metadata from the jar file "{0}" ...
044010=MetaData Management : Load of Metadata complete
044011=Cannot create Scanner for metadata, unsupported value type: {0}
044012=Cannot instantiate Scanner: {0}
044013=MetaData Management : Initialising for specified MetaData files and classes
044014=MetaData Management : Initialisation for specified MetaData files and classes complete
044015=MetaData file "{0}" does not contain valid MetaData!
044016=Errors were encountered when loading the specified MetaData files and classes. See the nested exceptions for details
044017=Class "{0}" has no MetaData or annotations.

044018=Populating all MetaData ...
044019=Initialising all MetaData ...
044020=Errors were encountered when initialising the specified MetaData. See the nested exceptions for details

044021=MetaData Management : Initialising for the persistence-unit "{0}"
044022=MetaData Management : Initialisation for persistence-unit "{0}" complete
044023=Errors were encountered when loading the MetaData for the persistence-unit "{0}". See the nested exceptions for details
044024=Errors were encountered when loading the MetaData for the jar-file "{0}". See the nested exceptions for details

044025=Metadata for member "{0}" is attempting to illegally override the primary-key setting of its "root" metadata definition (annotations or ".jdo" XML file). You must specify primary-key information in the "root" metadata definition

044026=Class "{0}" found to be part of persistence-unit "{1}" so loading it in case it is persistable
044027=Persistence-Unit "{0}" has a reference to mapping-file "{1}" but it was impossible to read it - {2}
044028=MetaData handler plugin "{0}" was not found. Please check your CLASSPATH and plugin specification.
044029=Error creating handler of type "{0}" for metadata parsing : {1}
044030=Parsing MetaData file "{0}" using handler "{1}" (validation="{2}")

044031=Attempt to parse file which was null!
044032=Error opening the Meta-Data file "{0}"
044033=Error reading the Meta-Data input "{0}"

044034=Class "{0}" defines {1} primary-key member(s) yet its superclass has already defined {2} other primary-key member(s); you cannot add extra primary key members down the inheritance tree

044036=Tag "{0}" cannot have the parent tag "{1}" : should be {2}
044037=Unknown tag : "{0}"
044038=MetaData Parser encountered an error in file "{0}" at line {1} : {2} - Please check your specification of DTD/XSD and the validity of the MetaData XML header that you have specified.
044039=MetaData Parser encountered an error in file "{0}" at line {1}, column {2} : {3} - Please check your specification of DTD/XSD and the validity of the MetaData XML header that you have specified.
044040=Parser error with file "{0}" has cause {1}
044041=A value is expected in the attribute "{0}" for "{1}" in element "{2}". 

044042=An error occurred while parsing <"{0}"> nested within "{1}" for URI "{2}"

044043=Registering class "{0}" as not having MetaData.
044044=Deregistering class "{0}" as not having MetaData - metadata now being added
044045=The file "{0}" contains metadata of type "{1}" but ought to contain metadata of type "{2}". Ignoring it.
044046=No "persistence.xml" file was found in the CLASSPATH. These files should be found under the META-INF/ directory in the root of a CLASSPATH entry/jar.
044047=Persistence-Unit "{0}" was not found in the available "persistence.xml" files.

044048=MetaData of type "{0}" for class "{1}" not found
044049=MetaData of type "{0}" for class "{1}" NOT found at {2}
044050=MetaData for query {0} NOT found at {1}
044051=MetaData for sequence {0} NOT found at {1}
044052=MetaData of type "{0}" for class "{1}" will use {2}
044053=MetaData for query {0} will use {1}
044054=MetaData for sequence {0} will use {1}
044055=Failure to parse MetaData file {0}
044056=File "{0}" is having internal MetaData definition updated with ORM information
044057=The package name in empty in MetaData file {0}.

044058=The package {0} has an empty MetaData specified for a class name. Please check the file {1}.

044059=Found Meta-Data for class {0} but this class is either not enhanced or you have multiple copies of the persistence API jar in your CLASSPATH!! Make sure all persistable classes are enhanced before running DataNucleus and/or the CLASSPATH is correct.
044060=Class "{0}" field "{1}" : Adding Meta-Data for member since it didn't appear in the Meta-Data definition.
044061="class" Meta-Data element for package {0} needs a 'name' attribute.

044062=Field "{0}" is defined to use TypeConverter with name "{1}" but this is not found. Please check your definition of type converters

044063=Class "{0}" has been specified to be persistable yet is an inner class and is not static. Non-static inner classes cannot be persistable.

044064=Class "{0}" is defined as having \"superclass-table\" inheritance and there is no known superclass with its own table. Duhhhhhhh

044065=Class {0} has application-identity and no objectid-class specified yet has {1} primary key fields. Unable to use SingleFieldIdentity.
044066=Class {0} has application-identity, no objectid-class and 1 PK field, but the field is of an invalid type {1} for SingleFieldIdentity. You are allowed to use short, Short, int, Integer, long, Long, byte, Byte, char, Character, or String types.
044067=Class "{0}" : No class loader specified for loading of classes associated with MetaData for this class. Using the default ClassLoader.
044068=Class "{0}" : Cannot populate the class since it is already populated.
044069=Class "{0}" : Meta-Data hasnt been initialised for the class
044070=Class "{0}" : Meta-Data hasnt been populated for the class
044071=Class "{0}" field "{1}" : declared in MetaData, but this field doesn't exist in the class!
044072=Class "{0}" : has property {1} declared in MetaData, but this method doesn't exist in the class!
044073=Class "{0}" : has property {1} declared in MetaData, but its getter method doesn't exist in the class!
044074=Class "{0}" : has property {1} declared in MetaData, but its setter method doesn't exist in the class!
044075=Class "{0}" : Populating Meta-Data
044076=Class "{0}" : Initialising Meta-Data
044077=Class "{0}" has been specified with an object-id class {1} yet no fields have been identified as primary key fields. Please notate using the "primary-key" tag against the fields that should be considered part of the primary key.
044078=Class "{0}" has been specified with {1} primary key fields, but this class is using {2} identity and should be application identity.
044079=Class "{0}" has been specified with an object-id class {1}. This class cannot be found. Please check your specification and/or CLASSPATH.
044080=Class "{0}" has MetaData yet the class cant be found. Please check your CLASSPATH specifications.
044081=Class "{0}" has a persistence-capable-superclass {1} which is not found.
044082=Class "{0}" has a persistence-capable-superclass {1} which is NOT a superclass of the class.
044083=Class "{0}" has a persistence-capable-superclass {1} which is not Persistence-Capable (no Meta-Data found).
044084=Class "{0}" has the persistence-capable-superclass {1}, but there is no metadata existing for the superclass.
044085=Class "{0}" has the persistence-capable-superclass {1}, but defines a different objectid-class than its superclass. No objectid-class should be specified because the superclasses id is always used.
044086=Class "{0}" has the persistence-capable-superclass {1} however it has been specified with an objectid-class. No objectid-class should be specified because the superclasses id is always used.
044087=Class "{0}" : The persistence-capable-superclass must be class {1}, NOT class {2}.
044088=Class "{0}" : The persistence-capable-superclass {1} cant be found. Please check your CLASSPATH specifications.
044089=Class "{0}" has had its persistence-capable-superclass set to "{1}" - it wasnt specified in the MetaData.
044090=Class "{0}" already has a field with the name {1} defined.
044091=Class "{0}" has not been declared with a persistence-capable-superclass, yet it has a superclass "{1}" that IS persistence capable. Please correct this error.
044092=Class "{0}" has a field {1} of type "{2}" yet this type is not found! Perhaps the metadata is incorrect/invalid?

044093=Class "{0}" : Identity Type is not the same as the Identity Type declared in super class.
044094=Class "{0}" : Datastore-identity strategy ("{1}") is not the same as the Datastore-Identity strategy declared in the super class(es) ("{2}").
044095=Class "{0}" is having internal MetaData definition updated with Annotations information
044096=Class "{0}" is having internal MetaData definition updated with ORM information
044097=Class "{0}" has MetaData with implements {1} yet the class cant be found. Please check your CLASSPATH specifications.
044098=Class "{0}" has been specified with an inheritance strategy of "{1}" yet only "{2}" is supported currently
044099=Class "{0}" has been specified with an inheritance strategy of "superclass-table", yet no superclass exists or none exists with its own table!
044100=Class "{0}" has been specified to use an inheritance strategy of "superclass-table", persisting to the table of class {1}, however this class doesn't have a discriminator specified.
044101=Class "{0}" has been specified to use an inheritance strategy of "superclass-table", persisting to the table of class {1}, however this class doesn't have a discriminator column specified.
044102=Class "{0}" has been specified to persist to table of class "{1}" using discriminator column {2}. No discriminator value has been specified for this class!
044103=Class "{0}" has a discriminator strategy of "value-map" but has no value. Will use the name of the class since nothing else is available!
044104=Class "{0}" has been specified with an inheritance strategy of "{1}" yet this is not currently supported by DataNucleus. Using default strategy instead
044105=Class "{0}" is abstract yet has been defined with a discriminator value. The value will never be used!

044106=Class "{0}" field "{1}" : Cannot populate the field with a null field.
044107=Class "{0}" field "{1}" : Cannot populate the field since it is already populated.
044108=Class "{0}" field "{1}" : Cannot update the field since it is already initialised.
044109=Class "{0}" field "{1}" : this is declared as {2} with "persistence-modifier={3}" yet has either "default-fetch-group=true" or "primary-key=true" specified! These should be false.
044110=Class "{0}" field "{1}" : this is declared with a "dependent" attribute, but it is a collection, array or map field for which dependency must be declared in an enclosed "array", "collection" or "map" tag, e.g. as "dependent-element" (for collections)   
044111=Class "{0}" field "{1}" : Cannot persist field since it is of an array type that is not supported by DataNucleus. Please consider making this a Collection field.
044112=Class "{0}" field "{0}" : has already been specified, yet has duplicate definition.
044113=Class "{0}" field "{1}" : specified to be from class "{2}" but this class could not be found!
044114=Class "{0}" field "{1}" : specified to be from class "{2}" but this class is not a superclass of the given class! You can only override fields in persistable superclasses
044115=Class "{0}" field "{1}" : has "mapped-by" specified as "{2}". This field doesnt exist in the target of the relation ("{3}")!!
044116=Class "{0}" field "{1}" : has "implementation-classes" specified yet the implementation class "{2}" is not found!!
044117=Class "{0}" field "{1}" : Cannot populate with a the value "{2}" for the property "{3}".

044118=Class "{0}" field "{1}" : marked as persistent yet is final so cannot be persisted

044119=Class "{0}" : A column without field has been specified without its "name". Any "unmapped" column must have a name.
044120=Class "{0}" : A column "{1}" without field has been specified without its "jdbc-type". Any "unmapped" column must have a jdbc-type so DataNucleus has a clue how to set its value.

044121=Class "{0}" field "{1}" is of type "{2}" yet has been specified as embedded. DataNucleus doesnt support embedding of this type. Your embedded type must be persistable.
044122=Class "{0}" field "{1}" is a collection with elements of type "{2}" yet has been specified as the element being embedded. Your embedded type must be persistable.
044123=Class "{0}" field "{1}" is a map with keys of type "{2}" yet has been specified as the key being embedded. Your embedded type must be persistable.
044124=Class "{0}" field "{1}" is a map with values of type "{2}" yet has been specified as the value being embedded. Your embedded type must be persistable.
044125=Class "{0}" field "{1}" : adding Meta-Data for field embedded in class "{2}" since it didn't appear in the <embedded> Meta-Data definition.

044126=Class "{0}" defines a discriminator column, yet so does a superclass! In the vast majority of cases this declaration will be ignored (unless you are having a discriminator column in multiple tables down an inheritance tree).

044127=Class "{0}" field "{1}" has been specified as SERIALIZED and with a CONVERTER ("{2}"). These are mutually exclusive. The SERIALIZED setting will be ignored.

044128=Class "{0}" is embedded and has member "{1}" embedded using the same type. You cannot embed recursively.

044129=Class "{0}" field "{1}" has been specified to embed an object of type "{2}", yet this type is an interface and has been specified with an embedded FIELD "{2}". This should be a PROPERTY.
044130=Class "{0}" field "{1}" has <join table="...">. The attribute "table" is not applicable within <join> when it is specified under <field>.
044131=Class "{0}" field "{1}" : has <collection> and the element-type has more than 1 value. DataNucleus supports a single value only. If you want to specify many implementations you should use "implementation-classes" DataNucleus extension.
044132=Class "{0}" field "{1}" has been defined with "collection" MetaData yet is not a Collection Field.
044133=Class "{0}" field "{1}" has been defined as a Collection but the element type has not been specified!
044134=Class "{0}" field "{1}" has been defined as a Collection with elements of type {2}. This element type is not found.
044135=Class "{0}" field "{1}" has been defined as a Collection with elements of type {2}. This type has been resolved to {3}

044136=Class "{0}" has been defined without a PK class but requires one, and uses property access so cannot auto-generate a PK class. Please provide a PK class

044137=Class "{0}" field "{1}" : has been specified with an order mapped-by yet the mapped-by field ("{2}.{3}") doesnt exist
044138=Class "{0}" field "{1}" : has been specified with an ordering with a field ("{2}.{3}") that doesnt exist
044139=Class "{0}" field "{1}" : has been specified with an ordering with an invalid direction ("{2}"). Should be either ASC or DESC
044140=Class "{0}" field "{1}" : has <array> and the element-type has more than 1 value. DataNucleus supports a single value only. If you want to specify many implementations you should use "implementation-classes" DataNucleus extension.
044141=Class "{0}" field "{1}" : has been defined with "array" MetaData yet is not an array field.
044142=Class "{0}" field "{1}" is an array of (non-serialised) elements of type "{2}" yet no <join> has been specified. You must have a join table to store an array of non-persistable elements, or serialise the array.
044143=Class "{0}" field "{1}" has <map> and the key-type has more than 1 value. DataNucleus supports a single value only. If you want to specify many implementations you should use "key-implementation-classes" DataNucleus extension.
044144=Class "{0}" field "{1}" has <map> and the value-type has more than 1 value. DataNucleus supports a single value only. If you want to specify many implementations you should use "value-implementation-classes" DataNucleus extension.
044145=Class "{0}" field "{1}" has been defined with "map" MetaData yet is not a Map Field.
044146=Class "{0}" field "{1}" has been defined as a Map but the key type is not specified!
044147=Class "{0}" field "{1}" has been defined as a Map with keys of type {2}. This key type is not found.
044148=Class "{0}" field "{1}" has been defined as a Map with keys of type {2}. This key type has been resolved to {3}.
044149=Class "{0}" field "{1}" has been defined as a Map but the value type is not specified!
044150=Class "{0}" field "{1}" has been defined as a Map with values of type {2}. This value type is not found.
044151=Class "{0}" field "{1}" has been defined as a Map with values of type {2}. This value type has been resolved to {3}.
044152=Class "{0}" field "{1}" has been specified with a key-type of "{2}" which is a reference type, and that it should be embedded into a join table. DataNucleus doesnt support embedding of reference types into join tables.
044153=Class "{0}" field "{1}" has been specified with a value-type of "{2}" which is a reference type, and that it should be embedded into a join table. DataNucleus doesnt support embedding of reference types into join tables.
044154=Class "{0}" : Query for has been specified without a name !
044155=Class "{0}" : Sequence has been specified without a name !
044156=The strategy was not specified !
044157=The strategy was not specified !
044158=The factory-class {0} was not found !
044159=The factory-class {0} does not implement javax.jdo.IdGenerator !
044160=Invalid specification of <extension> tag. The vendor-name ({0}), key ({1}) and value ({2}) must ALL be specified.
044161=Class "{0}" field "{0}" : declared as a reference type (interface/Object) but no implementation classes of "{2}" have been found!
044162=Class "{0}" field "{1}" : declared in metadata, yet there is no such persistent capable superclass with this field

044163=Class "{0}" has no table of its own, is using application-identity and has no primary key fields. Marking as not persistence instantiable
044164=Class "{0}" has {1} primary-key field(s) yet no objectidClass defined. Assumed to be "{2}"

044165=Embedded metadata has unsupported parent type {0}

044166=Class "{0}" member "{1}" has getter with void return! A getter must obey Java Bean conventions and return the type of the property
044167=Class "{0}" member "{1}" has a getter with return type {2} and setter taking argument of type {3}. These are not consistent with Java Bean conventions!

044200=Class "{0}" has been specified with {1} annotations so using those.
044201=Class "{0}" has an annotation "{1}" specified with property "{2}" yet this is invalid. Please check the specification for that annotation class.
044202=Class "{0}" has annotations but there is no registered AnnotationReader. Please check your CLASSPATH and the annotations in the class for validity.
044203=Class "{0}" has an annotation "{1}" which was not processed here (will be processed separately if a DataNucleus extension annotation).
044204=Class "{0}" : @Index specified but had no field/column specification and so is ignored
044205=Class "{0}" : @Unique specified but had no field/column specification and so is ignored
044206=Class "{0}" : @ForeignKey specified but had no field/column specification and so is ignored
044207=Class "{0}" : annotation reader of name "{1}" was not found. If this was a user-provided annotation reader then check your specification, otherwise report this to developers
044208=Could not find the handler for class annotation "{0}". Please report this
044209=Could not find the handler for member annotation "{0}". Please report this

044211=Class "{0}" field "{1}" has an annotation "{2}" which was not processed here (will be processed separately if a DataNucleus extension annotation).
044212=Class "{0}" field "{1}" : has been specified as a Container, however no support for type "{2}" has been found. Please check if you the correct definition or that you have the plugins which provide the ContainerHandlers support for the type in the CLASSPATH.

044213=Invalid value for metadata extension: "{0}" => "{1}"

#
# Datastore Connection
#
046000=Not valid to call method "{0}" on a data store connection obtained from the PersistenceManager.
046001=Connection is no longer available

#
# Query Result
#
052600=Query result has been closed
052601=Failed to read the result set : {0}
052602=No more elements in query result
052603=Query result sets are not modifiable
052604=This operation is not supported on Query Results
052605=Closing query result failed : {0}
052606=Reading in results for query "{0}" since the connection used is closing/committing
